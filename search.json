[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Get going with git",
    "section": "",
    "text": "Introduction\nThe topic of version control is quite broad and ranging. Additionally, the git, github, github cli and github pages etc version control technologies can be daunting for newcomers to set up and apply. However, once you have things installed (and configured) and you have a basic grip on how it all fits together at a high level, then you can go a long way with some introductory knowledge.\nI know, it is true that a little knowledge can be a dangerous thing, but it probably isn’t quite as bad as complete ignorance.\nThis text, Get going with git, aims to provide introductory knowledge that is sufficient to get you up and running with git as a means for version control. The primary focus is on the core sets of functionality.\nThe text can be browsed online or downloaded as a word document for your reference and will be used as a companion for a training workshop."
  },
  {
    "objectID": "notebooks/preamble.html#background-reading",
    "href": "notebooks/preamble.html#background-reading",
    "title": "Preamble (don’t skip)",
    "section": "Background reading",
    "text": "Background reading\nThere is no point reinventing the wheel, Jenny Bryant motivates the use of version control in the following paper: Excuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/preamble.html#objectives",
    "href": "notebooks/preamble.html#objectives",
    "title": "Preamble (don’t skip)",
    "section": "Objectives",
    "text": "Objectives\n\n\n\n\n\n\nNote\n\n\n\nThere is no getting around it. You are likely1 going to find some2 of this text hard and/or frustrating and/or/also painful.\nYour knowledge will progress in a stepwise fashion3 through setup, core concepts and collaboration. Each of these will give you pain, but once you have practice them, they will become an intuitive, integrated and a comforting safety net.\n\n\nThe approach I have taken is purposefully (and unapologetically) applied and a fairly low level perspective on git. The rationale stems from experience of this being the best way to build a clear and coherent understanding. Once you have the fundamentals practiced, it is much easier to pick up any git client of your choosing (from the long list of clients) safe in the knowledge that you have some insight into what is going on under the hood and that if things do go horribly wrong (as they invariably do) you have some chance of being able to fix them.\nThe goal here is for you to gain understanding into the fundamental aspects of revision control and git in particular. Once you have that base, extending from there will be much easier for you.\nThe pace of the workshop will be based on the abilities of the audience but there is an expectation that the audience practices the skills in their own time. The workshop is likely to be run over a few sessions but the exact length is yet to be determined. It is mainly targeted at analysts that are new to revision control but with some effort is accessible to anyone."
  },
  {
    "objectID": "notebooks/preamble.html#command-line-interfaces",
    "href": "notebooks/preamble.html#command-line-interfaces",
    "title": "Preamble (don’t skip)",
    "section": "Command line interfaces",
    "text": "Command line interfaces\nA command line interface (CLI) is a piece of software, supplied with the operating system, that you use to interact with your operating system via your keyboard rather than a mouse. Software that implements such a text interface is often called a command-line interpreter, command processor or a shell. You enter in commands as text and the system will do something, e.g. create a file, delete a file. Each of these commands is a piece of software that performs some function. git is one such command that facilitates access to a wide range of functions.\nPeople outside of software development and (some) analysts find the command line esoteric and redundant. They are wrong on both counts. At one stage, the CLI was the only way to interact with a computer. The approach provides an extremely useful set of tools that pay dividends if you make the effort to learn even a small set of them.\nNearly universally, if I use the word terminal or shell I am referring to the operating system command line interface. Windows refers to its CLI as the command prompt, and in macOS they use terminal. For the purposes here, you can treat all these terms as synonomous.\nIf you do not know how to operate your operating system CLI then you need to address that to make the most out of this text.\n\nWhy command line?\nBecause every other approach fundamentally rests on the git functionality that is exposed through the command line. While other approaches might abstract away from some of gits complexity, they also make some of the workings opaque. By learning the commandline functions, you focus on what you actually need and when you use another approach, you will understand what it is trying to achieve.\n\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nOld, but with applicable coverage of the basics - Windows Command Line Tutorials\nLinkedIn course - Learning Windows Terminal\n\nPlease do at least one of the above.\n\n\nmacOS\n\nHow To Use Terminal On Your Mac\nWhat Is the Mac Terminal?\nAbsolute BEGINNER Guide to the Mac OS Terminal\n\n\n\nExtra credit\n\nLearn the command line\n\n\n\n\n\n\n\nNote\n\n\n\nThe reason I haven’t mentioned Linux is simply because for Linux oriented people, it is reasonable to assume that this level of competence has already been met."
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management---environment-variables-etc",
    "href": "notebooks/preamble.html#operating-system-management---environment-variables-etc",
    "title": "Preamble (don’t skip)",
    "section": "Operating system management - environment variables etc",
    "text": "Operating system management - environment variables etc\nYou will need to have some minimal technical competence in navigating and driving your computer. For example, you need to know how to set an environment variable under your operating system of choice. If you do not know how to set an environment variable, then you will need to figure it out otherwise you won’t be able to use the tools that are going to be introduced here.\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nEnvironment Variables : Windows 10\nHow to Set Environment Variables in Windows 11\n\nyou should be able to set a user variable even if you do not have admin priviledges.\n\n\nmacOS\n\nHow to Set Environment Variables in MacOS\nPATH Variable (Mac)\nUse environment variables in Terminal on Mac"
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management",
    "href": "notebooks/preamble.html#operating-system-management",
    "title": "Preamble (don’t skip)",
    "section": "Operating system management",
    "text": "Operating system management\nCreate a directory on your machine where we will store all the files for this workshop.\nSimply go to the your Documents directory and create a sub-dir called get-going-with-git (you can call it what you want, but this is going to be the location of our scratchpad and temp work).\nThroughout this text, if I say go to your local workshop directory, this is the location I want you to go to."
  },
  {
    "objectID": "notebooks/preamble.html#github",
    "href": "notebooks/preamble.html#github",
    "title": "Preamble (don’t skip)",
    "section": "GitHub",
    "text": "GitHub\nFollow part 1 of the instructions provided by Getting started with your GitHub account to create and configure your account.\n\n\n\n\n\n\nWarning\n\n\n\nThe part on configuring 2-factor authentication is absolutely mandatory, the rest of the 2-factor content can be skimmed. See Configuring two-factor authentication.\n\n\nTo use the USyd GitHub Enterprise Server, you will need a unikey. If you have a unikey, you should have access. If you go here you can confirm that you can login, but note that you will not require access to the Enterprise Server to complete this course."
  },
  {
    "objectID": "notebooks/preamble.html#onedrive",
    "href": "notebooks/preamble.html#onedrive",
    "title": "Preamble (don’t skip)",
    "section": "OneDrive",
    "text": "OneDrive\nIt would be beneficial if you can install the desktop application for OneDrive so that you have file system integration (i.e. so that you can see your OneDrive through your file explorer app).\nYou may need to go to IT Support to get them to install OneDrive for you, but it may already be installed."
  },
  {
    "objectID": "notebooks/preamble.html#footnotes",
    "href": "notebooks/preamble.html#footnotes",
    "title": "Preamble (don’t skip)",
    "section": "",
    "text": "Actually with very high probability. Sorry.↩︎\nProbably a lot.↩︎\nMonotonically, I am sure. Ideally strictly positively.↩︎"
  },
  {
    "objectID": "notebooks/part-01.html",
    "href": "notebooks/part-01.html",
    "title": "Part 1 - Logistical elements",
    "section": "",
    "text": "In this part we will get everything set up. Prepare yourselves, this could be the most frustrating part."
  },
  {
    "objectID": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "href": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "title": "1  What is (this thing) called revision/version control?",
    "section": "1.1 The big picture",
    "text": "1.1 The big picture\nBefore we do any setup, let’s start with a big-picture. Version control is any practice that allows you to track and manage the evolution of a project.\nRemember filenames like document_v3.docx, document_v3_20230101.docx, document_v3_20230101_ts.docx? That is a manual, informal and unstructure approached to version control. You can tighten up the filenaming standards, but this approach is still very limited. For example, the approach is case by case, simultaneous changes and merges are tedious, can involve double handling and are error prone.\nA software implementation of revision control is a mechanism to understand a project/file history without having to used N^q distinct filenames to identify the different versions. Git is one of many revision control systems. In data science, IT and tech fields, it is the de-facto standard. If you ever aspire to working in a technical role in one of those fields, you would need to learn git.\nIrrespective, arguably, if you are collaborating, you should probably be using git.\nWhen you get going with git you will need to think in terms of repositories, not to be confused with suppositories. Repositories are where you project code is held.\ngit is by design a distributed system, but do not worry about that right now. Basically, there are two types of repository - local and remote. The local ones are those that reside on your own machine. The remotes ones are off in the void somewhere, but they can be linked and interact via git like this:\n\n\n\nBig picture\n\n\nRemote repositories are hosted by service providers, the most common being GitHub, GitLab and Bitbucket. We only deal with GitHub here. GitHub comes in a few varieties:\n\nGitHub Enterprise is hosted by the company called GitHub, see github.com. It is a commercial platform, but parts of it are made freely available.\nGitHub Enterprise Server is self-hosted; this is what USyd provides via https://github.sydney.edu.au/\n\nIn a nutshell, git provides a set of commands that allow you to manage the files that are retained in these local and remote repositories.\nAgain, I cannot sum it up better than Jenny, so please take the time to read it.\nExcuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/git-install.html#rstudio",
    "href": "notebooks/git-install.html#rstudio",
    "title": "2  Git install",
    "section": "2.1 RStudio",
    "text": "2.1 RStudio\nAside - is your instance of RStudio up to date? If not, update it. Ditto for R. Keep them both updated."
  },
  {
    "objectID": "notebooks/git-install.html#install-git",
    "href": "notebooks/git-install.html#install-git",
    "title": "2  Git install",
    "section": "2.2 Install git",
    "text": "2.2 Install git\nI am going to break this down into Mac and Windows because they are the two systems that most people use and the installation is somewhat different for each. If you are using Linux, you probably have no need to be reading this.\n\n2.2.1 Mac OSX\nFirst, do you have git installed already? Launch the terminal app (see the pre-requisites on the landing page if you do not know how to do this). In the terminal, type:\n\nwhich git\n\nwhich should show the location of the version of git in use. For me, its:\n\n## /opt/homebrew/bin/git\n\nIf you have homebrew (see Section 2.2.2 below) installed, you can just type:\n\nbrew install git\n\nand git will be installed, otherwise, follow the instructions below and then come back here.\nOnce git is installed run the which git command again and then run git --version which is shown (along with the output) below:\n\ngit --version\n## git version 2.42.0\n\nIf you got here, then you have git installed. You can close down terminal, open it up again and then run the git --version command again to make certain that everything is ok.\n\n\n2.2.2 Homebrew\nIn the previous section, you can see that the path output from the which git command includes homebrew. For macOS, homebrew is a package manager. This basically just lets you install and manage packages (applications) on your mac.\nTo use homebrew, you need to install it first. To do that, go here, then follow the instructions, which amount to going to the terminal and running the commands listed below.\nPlease go and read the landing page for homebrew before you proceed any further.\nThe first command ensures that pre-requisites are met, see here:\n\n xcode-select --install\n\nif this has already been done you will get an error, or be asked to run Software Update. Generally, you can just move on to the next command:\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\ncurl is a tool for transferring data from a url. It is usually stored under /usr/bin but if you are having issues then exporting the following might assist:\n\nexport HOMEBREW_FORCE_BREWED_CURL=1\n\nwhich basically tells homebrew to use its own version of curl. After the above is complete, homebrew should be installed. Now you can run\n\nbrew install git\n\nto install git for you.\nFor reference, here are a minimal set of commands for using homebrew (additional information can be found in the homebrew man pages).\nBasic information on homebrew:\n\n# Display the version of Homebrew.\n$ brew --version\n# Print Help Information\n$ brew help\n# Print Help Info for a brew command\n$ brew help &lt;sub-command&gt;\n# Check system for potential problems.\n$ brew doctor\n\nKeep your homebrew applications up to date:\n\n# Fetch latest version of homebrew and formula\n$ brew update\n# Show formulae with an updated version available\n$ brew outdated\n# Upgrade all outdated and unpinned brews\n$ brew upgrade\n# Upgrade only the specified brew\n$ brew upgrade &lt;formula&gt;\n# Prevent the specified formulae from being upgraded\n$ brew pin &lt;formula&gt;\n# Allow the specified formulae to be upgraded.\n$ brew unpin &lt;formula&gt;\n\nThe core commands for managing commandline applications are:\n\n# List all the installed formulae.\n$ brew list\n# Display all locally available formulae for brewing.\n$ brew search\n# Perform a substring search of formulae names for brewing.\n$ brew search &lt;text&gt;\n# Display information about the formula.\n$ brew info &lt;formula&gt;\n# Install the formula.\n$ brew install &lt;formula&gt;\n# Uninstall the formula.\n$ brew uninstall &lt;formula&gt;\n# Remove older versions of installed formulae.\n$ brew cleanup\n\nHomebrew casks allow you to install GUI applications. Unless you are an advanced user, you will rarely need to use these, but for completeness:\n\n# Tap the Cask repository from Github.\n$ brew tap homebrew/cask\n# List all the installed casks .\n$ brew cask list\n# Search all known casks based on the substring text.\n$ brew search &lt;text&gt;\n# Install the given cask.\n$ brew cask install &lt;cask&gt;\n# Reinstalls the given Cask\n$ brew cask reinstall &lt;cask&gt;\n# Uninstall the given cask.\n$ brew cask uninstall &lt;cask&gt;\n\n\n\n2.2.3 Windows\nThe official site for the git windows binary download is https://git-scm.com/download/win.\nIf you haven’t done all the install steps, download the 64-bit standalone installer, run it, agree to the conditions and license, choose the default location.\n\n\n\n\n\n\nNote\n\n\n\nThere might be some merit in re-installing git just to make sure you have the latest version and that you select the correct setup.\n\n\nEnsure that the following install components are chosen:\n\nwindows explorer integration\nlarge file support\n\nand accept any other defaults.\nWith the exception of the following, for any of the other prompts, just accept the defaults.\n\nYou will need to nominate a text file editor for editing commit messages and so on. Unless, you know what you are doing, I would advise just select the Windows Notepad application, you can reconfigure this later if you want to.\nYou should select to override the default branch name as main. The reason to do this is so that git aligns with github (which uses main as its default branch).\nFor adjusting the PATH environment variable, ensure that you select Git from the command line and also from 3rd-party software which is the default.\nEnsure that line ending conversion is set to Checkout as-is, commit as-is.\nFor the terminal emulator, select Use Windows default console window. This has some limitations but it is ok for an introduction. That said, if you are comfortable with the bash variant, do not let me stand in your way.\nEnsure that Git Credential Manager Core is selected when prompted.\n\nWe will run through this install for someone in the group.\nTo keep git up to date, you will need to go to the above site and download and reinstall git.\nOpen the command prompt and type:\n\ngit --version\n## git version 2.42.0"
  },
  {
    "objectID": "notebooks/git-setup.html#configuration-for-git",
    "href": "notebooks/git-setup.html#configuration-for-git",
    "title": "3  Git setup",
    "section": "3.1 Configuration for git",
    "text": "3.1 Configuration for git\nPer the sentiment of Fred Basset, you are now up but not quite running.\n\n\n\nFred Basset\n\n\nOne of the first things we need to do is to set a username and email address:\n\ngit config --global user.name \"Fred\"\ngit config --global user.email \"fred.basset@comic-land.com\"\n\nYou can list your configuration with\n\ngit config --global --list\n\nThe config is usually retained in a file in your home directory. It will be under ~/.git/config or simply ~/.gitconfig. If you look at this file, you will probably see that it is broken up into sections corresponding to user, global and so on. Don’t worry overly about that right now, it is just something to be aware of.\n\n\n\n\n\n\nNote\n\n\n\nThe tilde is just an abbreviation for the path to your home directory. If your home directory is /Users/mark then:\n~/Documents = /Users/mark/Documents == TRUE\n\n\nWe will get into the why later, but basically any interaction you have with git will be tied to your username and email address. This has obvious benefits if we want to be able to figure out who has done what, when and why.\nAnother tweak we will make is to the default branch name. Git always used to call this master by default. GitHub, in its infinite wisdom, appeared to make some judgement on the connotations of that default name and so changed it to main. This piece of config just makes Git consistent with GitHub.\n\ngit config --global init.defaultBranch \"main\""
  },
  {
    "objectID": "notebooks/github-setup.html#sec-github-setup",
    "href": "notebooks/github-setup.html#sec-github-setup",
    "title": "4  GitHub setup",
    "section": "4.1 GitHub account",
    "text": "4.1 GitHub account\nAs noted in the pre-requisites for using this knowledge base, you will need to have GitHub account.\nThe two ways to interact with GitHub are HTTPS and SSH. They are both secure protocols with the goal of protecting your credentials and your work. SSH can be a little harder to set up but has some advantages over HTTPS It is also less commonly used and can be problematic when firewalls are involved, so we will stick to HTTPS.\nA pre-requisite is to set up a Personal access token.\n\n4.1.1 Personal access token\nGitHub introduced personal access tokens a short while ago. Personal access tokens are basically a password with some bells and whistles.\n\nLogin to your GitHub account.\nOpen Creating a personal access token (classic) in a new tab in your browser and follow the instructions.\nSet the expiry to at least several months into the future.\n\n\n\n4.1.2 Create a private repo\nThis will just help us (you) with the subsequent steps. From your GitHub account, go up to the top right corner and select New -&gt; Repository You should get a page that looks like this:\n\n\n\nCreate private repo\n\n\nYou can call it whatever you want (temp is fine because we will delete it at some point in the future) but make sure to (1) select the Private radio button and (2) initialise a readme.md file."
  },
  {
    "objectID": "notebooks/github-setup.html#git-credential-manager",
    "href": "notebooks/github-setup.html#git-credential-manager",
    "title": "4  GitHub setup",
    "section": "4.2 Git Credential manager",
    "text": "4.2 Git Credential manager\nWhile SSH uses keys (along with a key agent which will normally already be on your machine) HTTPS relies on you to have some way to retain your credentials. That is, if you want to avoid having to enter your user name and token for every transaction you have with your GitHub repository, which is something you want to avoid. There is another alternative and that is to keep your credentials in a plain text file, but again that is strongly discouraged.\nEnter the Git Credential Manager (GCM).\nThe GCM is a platform agnostic credential manager (in English, that translates loosely to a password manager). Once it’s installed and configured, the Git Credential Manager is called by git and your interactions with GitHub become much more seamless.\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you’ll also need to complete the 2FA challenge.\nOnce you’ve authenticated successfully, your credentials are stored in the macOS keychain (or Windows equivalent) and will be used every time you clone an HTTPS URL. From there on in, git should not require you to type your credentials in the command line again (unless you change your credentials).\n\n4.2.1 GCM install\nFor Windows users it can be installed by selecting this option during the installation wizard, see Section 2.2.3, step 6. To display the current version, one of the following should help depending on which version of git you have:\n\ngit credential-manager version\n\n\ngit credential-manager-core --version\n\nFor macOS, use homebrew again, specifically:\n\nbrew install --cask git-credential-manager\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## ############################################################################################################################################## 100.0%\n## ==&gt; Downloading https://github.com/git-ecosystem/git-credential-manager/releases/download/v2.3.2/gcm-osx-arm64-2.3.2.pkg\n## ==&gt; Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/158405551/3b89ee5f-5275-4316-a794-6f39e38849c4?X-Am\n## ############################################################################################################################################## 100.0%\n## ==&gt; Installing Cask git-credential-manager\n## ==&gt; Running installer for git-credential-manager with sudo; the password may be necessary.\n## Password:\n## installer: Package name is Git Credential Manager\n## installer: Installing at base path /\n## installer: The install was successful.\n## 🍺  git-credential-manager was successfully installed!\n\nand then type:\n\ngit-credential-manager --version\n\nto confirm it was installed and is accessible.\n\n\n4.2.2 GCM demo\nBelow I demo the process by cloning a private repository from my GitHub account. You can use the temp repo that you just created, the URL will be something like https://github.com/&lt;your username&gt;/temp.git where you need to replace &lt;your username&gt;.\n\n192-168-1-100:tmp mark$ git clone https://github.com/maj-biostat/wisca_2.git\nCloning into 'wisca_2'...\ninfo: please complete authentication in your browser...\n\nat this point the following window is launch by GCM:\n\n\n\nGCM\n\n\nselecting Sign in with your browser the following will launch in your default browser (Chrome, Safari, etc)\n\n\n\nSign in with browser\n\n\nselecting Authorize git-ecosystem will result in\n\n\n\nSign in with browser\n\n\nat which point you use the 2-factor authenticator tool (e.g. google authenticator, microsoft authenticator etc) to respond with an authentication code.\n\n\n\nAuth success\n\n\nLooking back at the terminal, the following output can be observed, which details the repository being cloned.\n\nremote: Enumerating objects: 297, done.\nremote: Counting objects: 100% (297/297), done.\nremote: Compressing objects: 100% (156/156), done.\nremote: Total 297 (delta 148), reused 284 (delta 137), pack-reused 0\nReceiving objects: 100% (297/297), 7.85 MiB | 2.13 MiB/s, done.\nResolving deltas: 100% (148/148), done.\n\nFinally, you will receive an email of this sort to the email account that you have linked through GitHub.\n\nHey maj-biostat!\n\nA first-party GitHub OAuth application (Git Credential Manager) with gist, repo, and workflow scopes was recently authorized to access your account.\nVisit https://github.com/settings/connections/applications/0120e057bd645470c1ed for more information.\n\nTo see this and other security events for your account, visit https://github.com/settings/security-log\n\nIf you run into problems, please contact support by visiting https://github.com/contact\n\nThanks,\nThe GitHub Team\n\nOn repeating this process a second time, all the authentication works in the background and there will be no need to go through various authentication handshakes again.\nThe same process applies irrespective of whether you are using GitHub.com or the USyd GitHub Enterprise Server. However, it is adviseable to get this working in GitHub first and then work on getting it to work in the USyd GitHub Enterprise Server.\nThe transition from the old authentication approach has (so far) proved completely seemless for macOS. It will be interesting to see what happens for the Windows platform.\n\n\n4.2.3 GCM configuration (advanced only)\nYou can view the current credential manager by running the following commands:\n\ngit config --local credential.helper\ngit config --global credential.helper\n# /usr/local/share/gcm-core/git-credential-manager\ngit config --system credential.helper\n\n\n\n\n\n\n\nNote\n\n\n\nOf the local, global and system, the first one checks the local repository config, the second is your ~/.gitconfig, and the third is based on where git is installed. Note that only one of the git config commands returns a credential helper in the above example.\n\n\nIn some circumstances you may need to reconfigure things. If you have to start from scratch, the following may be useful:\n\ngit config --local --unset credential.helper\ngit config --global --unset credential.helper\ngit config --system --unset credential.helper\n\nFor windows uses check the contents of the credential manager. I believe that this can be accessed via Control Panel &gt;&gt; All Control Panel Items &gt;&gt; Credential Manager or by simply typing Credential Manager in the Windows task bar. Under generic credentials you should see the git entries."
  },
  {
    "objectID": "notebooks/github-setup.html#github-cli",
    "href": "notebooks/github-setup.html#github-cli",
    "title": "4  GitHub setup",
    "section": "4.3 GitHub CLI",
    "text": "4.3 GitHub CLI\nFor now, we can probably leave GitHub CLI setup, because I don’t think we will get to use it. It will be used in a more advanced introduction.\nIn the day to day grind, having to deal with GitHub through its Web interface can be a little cumbersome. You can avoid having to regularly interact with GitHub through the browser by using the GitHub CLI. This tooling allows you to review, create and manage your repositories from the comfort of your commandline. You can think of it as an extension of git that allows you to invoke the GitHub specific functionality.\nThe extremely terse gh CLI manual can be found here.\nFor Windows users, you can pick up the latest Signed MSI executables from the release page.\nFor macOS, use homebrew:\n\nbrew install gh\n## ==&gt; Downloading https://formulae.brew.sh/api/formula.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/manifests/2.37.0\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/331c0b76fd34aa97342efa0e4e41373dbac71c28aeb49346b1284b3450f4105b--gh-2.37.0.bottle_manifest.json\n## ==&gt; Fetching gh\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/blobs/sha256:a8c21e08d77963c2d12102aefe38f8c010c573b771ccf729ea438c40dddb7f3a\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/d0e6a3f8f7a4b138b36484ec9ec8aff26b499381a0b4459f53efc0aefe001ee2--gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Pouring gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Caveats\n## Bash completion has been installed to:\n##   /opt/homebrew/etc/bash_completion.d\n## ==&gt; Summary\n## 🍺  /opt/homebrew/Cellar/gh/2.37.0: 191 files, 44.2MB\n## ==&gt; Running `brew cleanup gh`...\n## Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.\n## Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).\n\n\n4.3.1 GitHub CLI authentication\nIn order to make use of gh we need to go through another round of authentication setup. To do this, go to the terminal and run:\n\ngh auth login\n## ? What account do you want to log into? GitHub Enterprise Server\n## ? GHE hostname: github.sydney.edu.au\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\n\nFor additional information, see gh auth –help.\nIn order to use gh with github.com directly you need to authenticate for that platform too. Repeat the above, but now the responses look like this:\n\ngh auth login\n## ? What account do you want to log into? GitHub.com\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\n\nYou are nearly set. You can verify that what you have configured worked via:\n\ngh auth status\n## github.sydney.edu.au\n##   ✓ Logged in to github.sydney.edu.au as mjon7053 (keyring)\n##   ✓ Git operations for github.sydney.edu.au configured to use https protocol.\n##   ✓ Token: gho_************************************\n##   ✓ Token scopes: gist, read:org, repo, workflow\n## \n## github.com\n##   ✓ Logged in to github.com as maj-biostat (keyring)\n##   ✓ Git operations for github.com configured to use https protocol.\n##   ✓ Token: gho_************************************\n##   ✓ Token scopes: gist, read:org, repo, workflow\n\nHowever, for gh to work with the desired host you need to set an environment variable to tell gh which platform to use. On macOS, you can set this up easily with the following entries in the .profile shell initialisation script (or .bash_profile for those inclined).\n\ngh-ent() {\n  export GH_HOST=github.sydney.edu.au\n}\n\ngh-std() {\n  export GH_HOST=github.com\n}\n\nOn Windows, I have no idea how you are supposed to do the above in an easy manner. You may just have to resort to running\n\nset GH_HOST=github.sydney.edu.au\n\nor\n\nset GH_HOST=github.com\n\neach time you want to switch.\nNow (on macOS) when you want to interrogate github.com repositories we can use the following commands.\n\n\n\n\n\n\nNote\n\n\n\nDo not worry about the meaning of the commands, this is just to establish that we have configured things correctly.\n\n\n\ngh-std\ngh repo list\n\n## Showing 30 of 185 repositories in @maj-biostat\n## \n## maj-biostat/misc-notes                         info for manjaro/arch linux setup                                public         1d\n## maj-biostat/wisca_2                            Revised approach to antibiogram                                  private        25d\n## maj-biostat/motc.run                                                                                            private        Sep 11, 2023\n## maj-biostat/motc.sim                           Simulation for motivate c trial                                  private        Sep 11, 2023\n## maj-biostat/motc.stan                          Stan models for motc                                             private        Sep  7, 2023\n## maj-biostat/quarto_demos_basic                 Demo using Quarto to render to word documents with custom te...  private        Aug 23, 2023\n## maj-biostat/BayesDRM                           Dose response models in stan                                     public         May 21, 2023\n## maj-biostat/motc.modproto                                                                                       public         May  1, 2023\n\nand for the USyd Enterprise GitHub Server, use:\n\ngh-ent\ngh repo list\n\n## Showing 12 of 12 repositories in @mjon7053\n## \n## mjon7053/motc-mgt            Monitoring statistics for Motivate-C study                       private  1d\n## mjon7053/fluvid.analyses     Analyses for fluvid coadministration study (COVID19 + FLU) vacc  private  17d\n## mjon7053/motc.sap                                                                             public   Sep ## 14, 2023\n## mjon7053/motc-sim-report     Motivate-C simulation report                                     private  Sep ## 12, 2023\n## mjon7053/roadmap-notes       Notes relating to the ROADMAP project.                           private  Sep ##  2, 2023\n## mjon7053/mjon7053.github.io                                                                   private  Aug 27, 2023"
  },
  {
    "objectID": "notebooks/part-02.html",
    "href": "notebooks/part-02.html",
    "title": "Part 2 - Fundamentals",
    "section": "",
    "text": "Now we will make a start with git. Initially we will focus on using git within the confines of your local machine. Yes, that’s right, for the moment, we won’t be using github at all. The point of this is to give you a chance to get to grips with the basic ideas. After the main concepts are bedded in, we will move to thinking about github, which is a whole new beast.\nWe will talk about the following;\n\nRepositories, how to set them up and some concepts.\nHow to interact with the repositories on a basic level.\nHow to compare and assess the present state of our repository\nBranches, what they are and what the are used for as well as setting them up\nMerging, what it is and how to do it\nGitHub, an overview"
  },
  {
    "objectID": "notebooks/git-repository.html#git-repositories",
    "href": "notebooks/git-repository.html#git-repositories",
    "title": "5  Repositories",
    "section": "5.1 Git repositories",
    "text": "5.1 Git repositories\nA repository is the most basic component of git. It is where the history is retained in terms of commits (it’s not correct but for the time being you can think of these as versions or snapshots of the files/repository).\nRepositories can be public or private, can involve single people or multiple collaborators and can be stored locally (on your personal computer), be located/stored in the cloud (in the cloud as in hosted by a service provider like github), or on a physical server (a basic file server will suffice in most cases), or just on your local machine.\nUsing the functions provided through git, you can create and configure repositories, add or remove files, review history of the files in the repository and much more.\n\n5.1.1 Initialisation\nLet’s initialise a new repository. Run the following on your machine:\n\n# Change dir to the local workshop directory, \n# e.g. cd ~/Documents/get-going-with-git\nmkdir first-repo\n\ncd first-repo\n\ngit init\n## Initialized empty Git repository in /Users/mark/Documents/project/misc-stats/first-repo/.git/\ngit status\n## On branch main\n## \n## No commits yet\n## \n## nothing to commit (create/copy files and use \"git add\" to track)\n\n\n\n\n\n\n\nNote\n\n\n\nThe repository is implemented by a hidden directory called .git that exists within the project directory and contains all the data on the changes that have been made to the files in the project. You should never touch this directory nor its contents.\n\n\nIf you received the output detailed above (or something very similar to it) then congratulations, you initialised a git repository.\nIf you have configured your file explorer to show hidden files, you will notice that the first-repo directory now contains a .git sub-directory. If you are running a Windows OS, then depending on what version you have, you may be able to run ls -la to list all files (i.e. including hidden files) within a directory.\nThis (.git) directory contains everything related to the repository.\n\n\n\n\n\n\nWarning\n\n\n\nIf you delete the .git directory, you will erase all of your commits. So, do not delete it unless you are absolutely certain this is what you want.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou can also create a repository from a pre-existing directory that has already got an established file structure and files. The process is exactly the same, just change to the directory that you want to add to version control, and run git init.\nWhen you create a new project in Rstudio, you can select to initialise a new git repository. Underneath the covers, RStudio is simply invoking git init.\n\n\n\n\n\n5.1.2 Repository structures\nBefore we start adding files to the new repository, you need to be aware of a few concepts.\nThere are three main structures within the repository:\n\nWorking directory\nStaging area\nCommit history\n\n\n\n\nRepository structures\n\n\n\n5.1.2.1 Working directory\nIs the usual files and sub-directories within your project directory. You add, update, rename, delete files and direcotries in this area. When you first create a file or directory within the working directory, it is not yet under version control. Such files are referred to as untracked files.\n\n\n5.1.2.2 Staging area\nIs a special space to where you list the files that are added to be committed as a new version under version control.\n\n\n5.1.2.3 Commit history\nAfter staging files, they are committed to the repository. Once committed, files (and directories) are under version control and are referred to as tracked files. A commit is simply a version, but you could also think of it as a transaction with the repository. Changes to committed files are monitored and new updates to files can be committed to the repository as work on the project progresses. Every time you commit files, the commit history is saved."
  },
  {
    "objectID": "notebooks/git-commit.html#adding-files-to-projects",
    "href": "notebooks/git-commit.html#adding-files-to-projects",
    "title": "6  Stage and Commit",
    "section": "6.1 Adding files to projects",
    "text": "6.1 Adding files to projects\nLet’s start to introduce files for the project. Open a text editor, enter the following contents (or download the readme.md file from the applicable section under Chapter 14) and save the file as readme.md in the first-repo directory.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nDitto for the following and save the file as hello.R in the first-repo directory.\n\ncat(\"Enter a string please: \");\na &lt;- readLines(\"stdin\",n=1);\ncat(\"You entered\")\n\nstr(a);\ncat( \"\\n\" )\ncat(a, file = \"log.txt\")\n\nRun the R script from the terminal by entering this text:\n\nRscript hello.R\n\nNow from the terminal in the first-repo directory:\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  hello.R\n##  readme.md\n##  log.txt\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)\n\nWe see that there are three untracked files, two of which we will ultimately want to store in the git repository. In contrast to the newly initialised repository as shown in Section 5.1.2 we now have the following:\n\n\n\nAdd file to working directory\n\n\nThe above is idealised. You may encounter the situation where you have many files, a number of which you have no intention of tracking under version control. You can ignore these files by creating a .gitignore file, which tells git which files it should ignore.\nCreate a new text file with the following content and save the file as .gitignore. This is a special configuration filename that git recognises. The . at the front of gitignore is important.\nIf you missed the . or mistakenly added a .txt extension then the .gitignore functionality will not work.\n\n# .gitignore file contains files\n# that the repository will ignore\nlog.txt\n*.txt\n\nIf you list (ls - la) the files in the first-repo directory, you should see the following (or something very similar):\n\n192-168-1-100:first-repo mark$ ls -la\ntotal 32\ndrwxr-xr-x  7 mark  staff  224  7 Nov 10:15 .\ndrwxr-xr-x  8 mark  staff  256  7 Nov 10:12 ..\ndrwxr-xr-x  9 mark  staff  288  7 Nov 10:15 .git\n-rw-r--r--@ 1 mark  staff   81  7 Nov 10:15 .gitignore\n-rw-r--r--@ 1 mark  staff  126  7 Nov 10:13 hello.R\n-rw-r--r--  1 mark  staff    4  7 Nov 10:14 log.txt\n-rw-r--r--@ 1 mark  staff   59  7 Nov 10:13 readme.md\n\nRun git status again and note that the log.txt file no longer registers with git.\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  .gitignore\n##  hello.R\n##  readme.md\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)"
  },
  {
    "objectID": "notebooks/git-commit.html#commit-process",
    "href": "notebooks/git-commit.html#commit-process",
    "title": "6  Stage and Commit",
    "section": "6.2 Commit process",
    "text": "6.2 Commit process\nNow we want to add the new file to the repository. The steps are\n\nAdd the file (or files) that we want to include in the repository to the staging area\nCommit the staged files\n\n\n6.2.1 Staging\nTo add the files into the staging area run the commands:\n\ngit add hello.R readme.md .gitignore\n\nNote that the .gitignore file was added as well as the hello.R and readme.md files. Now run\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Changes to be committed:\n##   (use \"git rm --cached &lt;file&gt;...\" to unstage)\n##  new file:   .gitignore\n##  new file:   hello.R\n##  new file:   readme.md\n\nWe can see that no commits have occurred but that we have staged the files that we want to add to the repository.\nWhat happens if we accidentally add a file that we did not want to add (the -f says we want to add a file that is included in the .gitignore list)?\n\ngit add -f log.txt\n\nif you run git status you will see that log.txt is also staged. To remove log.txt from the staged area:\n\ngit reset log.txt\n\nNow the picture looks like this.\n\n\n\nAdd file to staging area\n\n\n\n\n6.2.2 Commit\nTo commit the files that have been staged:\n\ngit commit -m \"First commit\" \n## [main (root-commit) 728d107] First commit\n##  3 files changed, 15 insertions(+)\n##  create mode 100644 .gitignore\n##  create mode 100644 hello.R\n##  create mode 100644 readme.md\n\nthe -m flag is necessary. When you make a commit, you need to provide a message that describes the nature of the changes.\nWhat is the weird stuff that is output prior to the commit message ([main (root-commit) 728d107]) in the commit history? It is a unique hash code that identifies this specific version of the project. Note, you will have a different hash code (and that is fine).\nWhen we run git status we see that the repository is up to date with the working area files. We also see that the files have been removed from the staging area.\n\ngit status\n## On branch main\n## nothing to commit, working tree clean\n\n\n\n\nCommit files to history"
  },
  {
    "objectID": "notebooks/git-commit.html#exercises",
    "href": "notebooks/git-commit.html#exercises",
    "title": "6  Stage and Commit",
    "section": "6.3 Exercises",
    "text": "6.3 Exercises\n\nExercise 6.1 Create a new R script in the working directory, it can contain anything you like. If you are lost, just use:\n\nlibrary(survival)\nprint(\"My script\")\n\nand save it as myscript.R.\n\n\nExercise 6.2 Add the new script to the staging area by following Section 6.2.1 ensuring that you review the status.\n\n\nExercise 6.3 Commit the staged files to the repository by following Section 6.2.2 making sure that you record a message for your commit.\n\n\nExercise 6.4 Edit the readme.md (use notepad or rstudio) file adding a new line with some arbitrary text. Stage the file and commit."
  },
  {
    "objectID": "notebooks/git-commit.html#tracking-commit-history",
    "href": "notebooks/git-commit.html#tracking-commit-history",
    "title": "6  Stage and Commit",
    "section": "6.4 Tracking commit history",
    "text": "6.4 Tracking commit history\nOne of the most notable features of revision control is that you can review your project file history. The simplest way to do this is with git log which will report all of the commits in reverse chronological order. You can see\n\nwho made the commits\nwhen they were made and why (the commit messages)\nthe hash code associated with project version at each commit\n\nnote that the full hash is reported whereas previous a truncated version is shown\n\n\nThe commit followed by (HEAD -&gt; main) shows what part of the history our working directory currently reflects.\nHere is an example (your repository will look different but that is ok)\n\ngit log\n\n## commit 327170a6bc4d39463c4cfbc0f257420496642cb5 (HEAD -&gt; main)\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:25:23 2023 +0800\n## \n##     Minor edit\n## \n## commit b078716e80498c2fa7abfb8ae27b204b2dc603d8\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:24:58 2023 +0800\n## \n##     New file\n## \n## commit 0cd2d52e989059a61315525a3488e06d22cd04a5\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:23:23 2023 +0800\n## \n##     First commit\n\nYou can format the logs in a variety of ways. For a more condensed view you can use the --oneline flag:\n\ngit log --oneline\n## 327170a (HEAD -&gt; main) Minor edit\n## b078716 New file\n## 0cd2d52 First commit\n\nIf you want the commit history for the last n commits, or between specific dates, or by author or even via searching for a specific string in the message you can run the following\n\ngit log -n 2\ngit log --after=\"2013-11-01\" --before=\"2023-10-15\"\ngit log --author=\"Mark\\|Fred\"\ngit log --grep=\"first\" -i\n\nTry them.\nThe first restricts to the last two commits, the second returns commits between mid Oct and the start of Nov, the second returns commits made by Mark or Fred and the third returns any commits where the word first was included in the message text (ignoring case).\nThe log command is powerful and it lets you see who updated the files, when they made the update and why they did it. Obviously, this has less utility when you are working on a repository in isolation but it still does have value (especially to your future self). For example, you might simply want to review when specific changes were made to the files or you might want to pick up some update that has been removed from the code and reintroduce it.\nWhen you are working on a repository in collaboration (see later) the value of the logs increases many fold as a way to be able to understand the evolution of the project and to work out who you need to contact if you think a problem has been introduced.\nTo establish what files were included in any given commit, you can use git show:\n\ngit show --name-only 0cd2d52\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:23:23 2023 +0800\n## \n##     First commit\n## \n## .gitignore\n## hello.R\n## readme.md"
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "href": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "title": "7  Reviewing differences",
    "section": "7.1 Comparisons with the working directory",
    "text": "7.1 Comparisons with the working directory\nGit allows you to compare different versions of files that exist in the repository. In its vanilla form, the difference functionality compares the differences in a file (or files) in the working directory to the repository version.\nUpdate the contents of the hello.R script to match what follows.\n\ncat(paste0(\"What is your name?\\n\"));\nnme &lt;- readLines(\"stdin\",n=1);\ncat(paste0(\"Hi \",nme, \" enter a string please: \\n\"));\na &lt;- readLines(\"stdin\",n=1);\ncat(\"You entered the following string: \")\ncat(paste0(a, \"\\n\"));\ncat(a, file = \"log.txt\")\n\nSimilarly, edit the readme.md file as below.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nA new line for testing.\n\nContains standalone R scripts.\n\nRunning git status you will see that the working directory uncommitted changes\n\ngit status\n## On branch main\n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   hello.R\n##  modified:   readme.md\n## \n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf we want to know what changes were made, we can run git diff but let’s looks at the differences on a file by file basis, comparing the old with the new.\n\ngit diff readme.md\n## diff --git a/readme.md b/readme.md\n## index 7501d7c..6929e2c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,5 +4,7 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## +Contains standalone R scripts.\n## +\n\nYou interpret the above as follows.\n\nAnything prefixed with - belongs to the old file and anything prefixed with + belongs to the new.\nThe section labelled with @@ gives you some context as to where the change has happened. In this case we can see that the text A minor revision has been removed and replaced with the text The main script implements a loop to capture input from a user.\n\nNow compare the working version of hello.R with the repository version, but this time look at the word by word differences:\n\ngit diff --word-diff hello.R\n## diff --git a/hello.R b/hello.R\n## index 0c6d38c..5f09b06 100644\n## --- a/hello.R\n## +++ b/hello.R\n## @@ -1,7 +1,9 @@\n## [-cat(\"Enter-]{+cat(paste0(\"What is your name?\\n\"));+}\n## {+nme &lt;- readLines(\"stdin\",n=1);+}\n## {+cat(paste0(\"Hi \",nme, \" enter+} a string please: [-\");-]{+\\n\"));+}\n## a &lt;- readLines(\"stdin\",n=1);\n## cat(\"You [-entered\")-]\n## \n## [-str(a);-]\n## [-cat( \"\\n\" )-]{+entered the following string: \")+}\n## {+cat(paste0(a, \"\\n\"));+}\n## cat(a, file = \"log.txt\")\n\nThe diffs can take a bit of getting used to and some alternative tools are available that we will put to use in due course. For now, we will just deal with the commandline output.\nOnce satisfied that the changes are benign, stage and commit the edits in the usual way:\n\ngit add hello.R readme.md\ngit commit -m \"Revised approach in capturing user input\""
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "href": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "title": "7  Reviewing differences",
    "section": "7.2 Comparisons with staged files",
    "text": "7.2 Comparisons with staged files\nIf you want to restrict your attention to the differences that will be made to a repository due to committing staged files, you can use git diff --cached."
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "href": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "title": "7  Reviewing differences",
    "section": "7.3 Comparisons across commit versions",
    "text": "7.3 Comparisons across commit versions\nOnce working directory changes have been committed to the repository it is still possible to review the differences between commit.\nThe most common difference that is of interest is that between the last two commits. To achieve this run\n\ngit diff HEAD 327170a\n\nTo inspect differences between any commits, you simply supply the commit hashes that you want to compare:\n\ngit diff b078716 0cd2d52\n## diff --git a/myscript.R b/myscript.R\n## deleted file mode 100644\n## index a12204c..0000000\n## --- a/myscript.R\n## +++ /dev/null\n## @@ -1,3 +0,0 @@\n## -library(survival)\n## -print(\"My script\")\n## -\n\nIf you want to restrict attention to a particular file, just add the filename that you want to compare to the end of the command\n\ngit diff HEAD 327170a readme.md\n## diff --git a/readme.md b/readme.md\n## index 6929e2c..7501d7c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,7 +4,5 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## -Contains standalone R scripts.\n## -"
  },
  {
    "objectID": "notebooks/git-branch.html#what-is-a-branch",
    "href": "notebooks/git-branch.html#what-is-a-branch",
    "title": "8  Branches",
    "section": "8.1 What is a branch?",
    "text": "8.1 What is a branch?\n\n\n\n\n\n\nWarning\n\n\n\nWe are going to step it up a notch. The topic of branching can be challenging for beginners. Practice and repitition is key to understanding. Try not to panic. At a basic level, it is actually straight forward once you get familiar with the processes.\n\n\nBranching is simply a mechanism that allows you to diverge from the main line of development and continue to do work without messing with that main line. They allow multiple pieces of work to be progressed independently within the same project. Ideally, you want to introduce each homogenous change within the context of its own branch.\nWhen you run git status you saw the text - On branch main as part of the output. You can think of main as your default branch. Similarly, when you ran git log the last commit reported is suffixed with (HEAD -&gt; main). Both of these were a reference to the version on the branch that is currently linked to the working directory.\nFor example, initially there is a singular progression of the project, but at some point you will want to create a release for a software product, or a piece of documentation or an analysis. Later you may want to revise the release due to changes in project direction, new data, bugs etc. You use branches to facilitate this process in a logical and coherent way. Typically, you branch off from the default branch of a repository, but you can branch from any branch that exists.\nIn the examples encountered so far, the branching we have encountered is just a stem (specifically, the main branch). Here is a common type of representation of the kind of branch that we have dealth with so far. The circles represent each commit, which would refer to changes in one or more files. The repository has gone through a series of commits (1, 2, 3, 4 etc.) and the working directory is currently looking at the repository version 4.\n\n\n\nBranch more like a stem\n\n\nThe arrow pointing at 4 is the current HEAD of the repository. HEAD is a special concept in git. It answers the question “What am I currently looking at?”"
  },
  {
    "objectID": "notebooks/git-branch.html#time-travel",
    "href": "notebooks/git-branch.html#time-travel",
    "title": "8  Branches",
    "section": "8.2 Time travel",
    "text": "8.2 Time travel\nThe concepts associated with branching are easiest understood by demonstration and experimentation.\nWhen you make a new commit to git, the branch reference is updated to point to the new commit. When you move to a new branch, the HEAD reference is updated to point to the branch that you switched to.\nGo to the Chapter 14 resources page and save the branching.R file to your first-repo directory.\nThe file contains the following:\n\n\nCode\n# R script to demo branching\nsuppressPackageStartupMessages(library(data.table))\nsuppressPackageStartupMessages(library(survival))\nsuppressPackageStartupMessages(library(rtables))\nsuppressPackageStartupMessages(library(ggplot2))\n\nmessage(\"-------------------------------\")\nmessage(\"NOW WE WILL MOVE ONTO BRUNCHING\\n\")\nmessage(\"-------------------------------\")\n\n\n# Data generation  ------------------\nset.seed(1)\n\nN &lt;- 4000\nd &lt;- data.table(\n  id = 1:N,\n  u = rbinom(N, 1, 0.5)\n)\n\nd[u == 0, x := rbinom(.N, 1, 0.2)]\nd[u == 1, x := rbinom(.N, 1, 0.8)]\n\nb0 &lt;- 3\nb1 &lt;- 1\nb2 &lt;- -2\nb3 &lt;- -1\ne &lt;- 1\nw_cens &lt;- 4\n\n# Continuous outcome\nd[, mu := b0 + b1 * x + b2 * u + b3 * x * u]\nd[, y := rnorm(.N, mu, 1)]\n\n# Binary outcome\nd[x == 1, z := rbinom(.N, 1, 0.7)]\nd[x == 0, z := rbinom(.N, 1, 0.3)]\n\n# Survival outcome\n# Median tte -log(0.5)/0.6 vs -log(0.5)\nd[x == 1, w := rexp(.N, 0.6)]\nd[x == 0, w := rexp(.N, 1.0)]\nd[, evt := as.integer(w &lt; w_cens)]\nd[evt == 0, w := w_cens]\n\n# Labels\nd[x == 0, arm := \"FBI\"]\nd[x == 1, arm := \"ACTIVE\"]\n\nd[u == 0, age := \"&lt; 50 years\"]\nd[u == 1, age := \"&gt;= 50 years\"]\n\n# Descriptive summary -------\n\nmessage(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n\nlyt &lt;- basic_table() %&gt;%\n  split_cols_by(\"arm\") %&gt;%\n  summarize_row_groups() %&gt;%\n  analyze(\"y\", mean, format = \"xx.x\")\n\nbuild_table(lyt, d)\n\n# Analyses --------\n\nmessage(\"\\n\\nANALYSIS OF CONTINOUS OUTCOME (UNSTRATIFIED):\\n\")\n\nlm1 &lt;- lm(y ~ x, data = d)\nsummary(lm1)\n\n\nRun the script:\n\nRscript branching.R\n\nImagine this was the first analysis for a project and will be sent to the clients. The completed work represents a milestone for the project so we stage and commit the file and then create a tag for it.\n\ngit tag -a v1.0 -m \"Analysis 1\"\n\nWe continue with the work for the next deliverable completing a secondary analysis on the binary outcome z. Add the following code to the end of the branching.R script, re-run with Rscript branching.R and then commit the file to the repository.\n\nmessage(\"\\n\\nANALYSIS OF BINARY OUTCOME (UNSTRATIFIED):\\n\")\n\nlm2 &lt;- glm(z ~ x, data = d, family = binomial)\nsummary(lm2)\n\npr &lt;- predict(lm2, newdata = data.table(x = 0:1), type = \"response\", se = T)\nd_fit &lt;- data.table(\n  arm = c(\"PBO\", \"ACTIVE\"),\n  x = 0:1,\n  pr_z = pr$fit,\n  pr_z_lb = pr$fit - 2 * pr$se.fit,\n  pr_z_ub = pr$fit + 2 * pr$se.fit\n)\n\nWe are not finished with our second deliverable, but at this point we realise that the initial analysis that was sent to the client was incorrect. As you may have spotted, we should have run a stratified analysis due to the presence of a confounder. We urgently need to re-issue the corrected analysis to the client. Bummer.\nIn contrast to the minor change above, in real life we might be much further along with this next deliverable, which may be vastly more complex than what I have illustrated above. For example, we may have introduced new files, restructured the original analysis, added functionality etc.\nWhile we could go through the process of winding back all the changes, with revision control we do not have to because we can rewind to any point.\nNext we go over the processes involved.\n\n8.2.1 Commit\nFirst thing to do is to check that your code is running ok and then commit any files that have not yet been committed to the repository. Not doing so will cause you some major headaches, so best advice is to not forget to do this.\n\ngit status\ngit add braching.R\ngit commit -m \"Commit of files part way through development\"\n\n\n\n8.2.2 Rewind\nNow we want to rewind our repository back to the time at which the deliverable was made. We can do this by using git log to find the commit hash or we can just use the tag that we set for the release. Using the tag is more convenient so let’s do that.\n\ngit log --oneline\ngit checkout v1.0\n## Note: switching to 'v1.0'.\n## \n## You are in 'detached HEAD' state. You can look around, make experimental\n## changes and commit them, and you can discard any commits you make in this\n## state without impacting any branches by switching back to a branch.\n## \n## If you want to create a new branch to retain commits you create, you may\n## do so (now or later) by using -c with the switch command. Example:\n## \n##   git switch -c &lt;new-branch-name&gt;\n## \n## Or undo this operation with:\n## \n##   git switch -\n## \n## Turn off this advice by setting config variable advice.detachedHead to false\n## \n## HEAD is now at a2cc6f7 Comments from code review\n\nIn terms of the schematic of the repository, the environment now looks like this.\n\n\n\nRewind to earlier deliverable\n\n\nWe have move the HEAD such that our working versions now point to the files that were originally delivered to the client.\n\n\n\n\n\n\nNote\n\n\n\nDon’t panic overly about the warning about being in the detached HEAD state.\n\n\nIf you look at branching.R you will see that the starts of the secondary analysis has disappeared.\n\n\n8.2.3 Fix issue\nIn order to fix the analysis we need to introduce the confounder as a covariate in the linear model. Introduce the following fixes. First to the descriptive summary:\n\nmessage(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n\nlyt &lt;- basic_table() %&gt;%\n  split_cols_by(\"arm\") %&gt;%\n  split_rows_by(\"age\") %&gt;%\n  summarize_row_groups() %&gt;%\n  analyze(\"y\", mean, format = \"xx.x\")\n\nbuild_table(lyt, d)\n\nand then to the analysis make these corrections and finally re-run the script to confirm that it produces what we expect.\n\nlm1 &lt;- lm(y ~ x * u, data = d)\nsummary(lm1)\n\nStage and then commit these changes. We can get some insight into the state of the tree now. Below I have added one more commit so that you can get a sense of how things are progressing.\n\ngit log --oneline --decorate --graph --all\n## * 7ab12b3 (HEAD) Code review correction\n## * 4cca810 Added emergency fix\n## | * c82a48d (main) Started on secondary analyses\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\nThe equivalent illustration would look something like this:\n\n\n\nAdd a fix\n\n\n\n\n8.2.4 Make permanent\nNow that we have fixed the code, we want to make the change permanent. That is, we want to formally tell git that our alternative history should be maintained. The way to do that is to create a new branch out of the recent changes (which already look like a branch).\n\ngit branch fix-01\n# Switch to new branch\ngit checkout fix-01\n\nWhen we look at the tree we see both HEAD and the branch (note the first line text which says HEAD, fix-01).\n\ngit log --oneline --decorate --graph --all\n## * 7ab12b3 (HEAD, fix-01) Code review correction\n## * 4cca810 Added emergency fix\n## | * c82a48d (main) Started on secondary analyses\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\nAnd now the picture is\n\n\n\nLooking at the HEAD of our new branch\n\n\nIf this is the version that we re-issue to the client, we might as well tag it.\n\ngit tag -a v1.1 -m \"Analysis 1 (re-issue)\"\n\n\n\n8.2.5 Switching back to the secondary\nSwitching back to our partially complete secondary analysis is as simple as.\n\ngit checkout main\n\nIf you look at the branching.R script you will be able to see the secondary analysis we started some time ago. However, if you look closely you will see that the changes we just made in the fix-01 branch have not yet been propagated to the main branch. It is important that we pick up this fix.\nThis process is known as merging and it will be tackled later."
  },
  {
    "objectID": "notebooks/git-merge.html#recap",
    "href": "notebooks/git-merge.html#recap",
    "title": "9  Merge",
    "section": "9.1 Recap",
    "text": "9.1 Recap\nFrom the previous branching example -\n\nWe delivered stage one of an analysis to the client\nWe started on the secondary analyses\nBefore the secondary analysis was complete, we realised there was an error in the original analysis that needed an emergency fix\nWe rewound to an earlier state in the repository and then fixed the error and checked in our work\nWe made the work permanent by creating a new branch and then checking out that branch\nWe tagged the fix and the re-issued the analysis to the client\nWe jumped back to our secondary analysis by checking out the main branch\n\nOk, so now we have a fix to the error in the original analysis in one branch fix-01 and a partially completed secondary analysis on the main branch. We want to bring the changes from the fix into our present work."
  },
  {
    "objectID": "notebooks/git-merge.html#merge-processes",
    "href": "notebooks/git-merge.html#merge-processes",
    "title": "9  Merge",
    "section": "9.2 Merge processes",
    "text": "9.2 Merge processes\nThere are two related approaches for combining your changes into a shared repository; rebase and merge. Personally, I never use git rebase and always use git merge. Mainly this is because the complexity of the repositories that I work on never justifies the rebase approach. Rebasing rewrites commits from one branch to another whereas merge retains the full repository history.\nMerging is usually a fairly automated process. Run the following.\n\ngit checkout main\ngit merge fix-01\n\nYou may be prompted to enter a commit message (alternatively just provide the -m flag).\n\nMerge branch 'fix-01'\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n\nand then the following output.\n\n## Auto-merging branching.R\n## Merge made by the 'ort' strategy.\n##  branching.R | 3 ++-\n##  1 file changed, 2 insertions(+), 1 deletion(-)\n\nIf you look at the difference between the HEAD (the HEAD~1 notation means compare with the previous commit, HEAD~2 means compare with 2 commits prior and so on) and the commit associated with the merge you will see\n\ngit diff HEAD~1\n## diff --git a/branching.R b/branching.R\n## index b60c9f0..8f1c1b3 100644\n## --- a/branching.R\n## +++ b/branching.R\n## @@ -45,6 +45,7 @@ message(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n## \n##  lyt &lt;- basic_table() %&gt;%\n##    split_cols_by(\"arm\") %&gt;%\n## +  split_rows_by(\"age\") %&gt;%\n##    summarize_row_groups() %&gt;%\n##    analyze(\"y\", mean, format = \"xx.x\")\n## \n## @@ -54,7 +55,7 @@ build_table(lyt, d)\n## \n##  message(\"\\n\\nANALYSIS OF CONTINOUS OUTCOME (UNSTRATIFIED):\\n\")\n## \n## -lm1 &lt;- lm(y ~ x, data = d)\n## +lm1 &lt;- lm(y ~ x * u, data = d)\n##  summary(lm1)\n## \n##  message(\"\\n\\nANALYSIS OF BINARY OUTCOME (UNSTRATIFIED):\\n\")\n\nWe now have the changes from the emergency fix in the main branch and we can continue with the secondary analysis.\nSometimes merging doesn’t work quite so smoothly and we need to iron out conflicts."
  },
  {
    "objectID": "notebooks/git-merge.html#exercises",
    "href": "notebooks/git-merge.html#exercises",
    "title": "9  Merge",
    "section": "9.3 Exercises",
    "text": "9.3 Exercises\n\nExercise 9.1 Complete the analysis by adding the following code to generate a figure from the fitted model.\n\np1 &lt;- ggplot(d_fit, aes(x = arm, y  = pr_z)) +\n  geom_point() +\n  geom_linerange(aes(ymin = pr_z_lb, ymax = pr_z_ub)) +\n  scale_x_discrete(\"\") +\n  scale_y_continuous(\"Probability of response\")\n\nggsave(\"fig-sec.png\", p1, width = 10, height = 10, units = \"cm\")\n\nHere is what you need to do:\n\nRun the updated script Rscript branching.R to make sure it works.\nEdit the .gitignore file so that the figure does not get committed to the repository.\nStage and commit the files and then review the commit history.\nCreate a v2.0 tag with an meaningful message.\n\n\n\nExercise 9.2 Usually it makes sense to create a new branch for each piece of development we undertake. This ensures that the main branch continues to reflect a working version at all times. Create a new branch from the current state and call it analysis-03. Run the following code:\n\ngit branch analysis-03\ngit checkout analysis-03\ngit status\n\nAdd the analysis code into branching.R\n\nmessage(\"\\n\\nANALYSIS OF SURVIVAL OUTCOME (UNSTRATIFIED):\\n\")\nlm3 &lt;- coxph(Surv(w, evt) ~ x, data = d)\nsummary(lm3)\n\nRun the script to make sure it works then stage and commit along with an updated .gitignore files that excludes all png files.\nCheckout main:\n\ngit checkout main\n\nAdd the following change to the branching.R code (just adding a new theme to the ggplot figure)\n\np1 &lt;- ggplot(d_fit, aes(x = arm, y  = pr_z)) +\n  geom_point() +\n  geom_linerange(aes(ymin = pr_z_lb, ymax = pr_z_ub)) +\n  scale_x_discrete(\"\") +\n  scale_y_continuous(\"Probability of response\") +\n  theme_bw()\n\nRun the script, then stage and commit.\nCheckout analysis-03 branch:\n\ngit checkout analysis-03\n\nAdd the following code:\n\npng(\"fig-surv.png\")\nplot(survfit(Surv(w, evt) ~ x, data = d), lty = 1:2)\ndev.off()\n\nRun the script to make sure it works then stage and commit. Treat this as the release by tagging it as v3.0. Checkout the main branch and merge the analysis into main.\n\ngit checkout main\ngit merge analysis-03\n\nReview the commit history:\n\ngit log --oneline --decorate --graph --all\n## *   2829471 (HEAD -&gt; main) Merge branch 'analysis-03'\n## |\\\n## | * be09457 (tag: v3.0, analysis-03) Finished surv\n## | * 7a5e7b9 Surv analysis\n## * | 53115b6 minor\n## |/\n## * 1a9dfeb (tag: v2.0) Edits from code review\n## * d1586df Completion of secondary analysis\n## *   bf34b9c Merge from fix-01\n## |\\\n## | * b8de16c (tag: v1.1, fix-01) Edits from code review\n## | * 12561d9 Emergency fix\n## * | d88f9e5 WIP\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\n\nAt this point, you have the fundamentals. However, there are things that are going to catch you out. For example, in the above work, we used three-way merges. These are convenient but can also get messy when your branching structure gets complex. In most of our daily work merges will probably suffice, but know that there is another way. The other way is rebasing, but we will not deal with it here."
  },
  {
    "objectID": "notebooks/github-101.html#walk-around-the-interface",
    "href": "notebooks/github-101.html#walk-around-the-interface",
    "title": "10  GitHub introduction",
    "section": "10.1 Walk around the interface",
    "text": "10.1 Walk around the interface\nWhen you log into GitHub you will be taken to your dashboard (homepage) which is a bit of a feed, quick links to some of your repositories and other things that might be of interest. Day to day, what you probably want to see and interact with is your repositories and their settings.\n\n\n\nGitHub landing\n\n\nGo to the top right hand corner and click the far right icon to get the drop down, then select your profile. All of the following is based on my account but you can follow along under your login as well, just replace my username with yours in the relevant places.\n\n\n\nGitHub landing dropdown\n\n\nFrom there you can edit various details pertaining to yourself, review your stats and so on and then jump into the git repositories that you have put onto GitHub.\n\n\n\nGitHub profile\n\n\nSelect the repository link to see a list of all your repositories. You can also get here directly from your landing page via the ‘Your repositories’ link. I have highlighted the get-going-with-git repo. You won’t have this repository at this stage (you might not have any) but that’s ok, just follow along.\n\n\n\nGitHub repository listing\n\n\nSelecting a specific repository brings up its landing page which includes the repository files, a description file, stats on the repository, settings and various other items. The page that is shown below corresponds to the git repository used to manage this knowledge base and website.\n\n\n\nGitHub repository landing page"
  },
  {
    "objectID": "notebooks/github-101.html#common-functions-via-github",
    "href": "notebooks/github-101.html#common-functions-via-github",
    "title": "10  GitHub introduction",
    "section": "10.2 Common functions via GitHub",
    "text": "10.2 Common functions via GitHub\nSome (if not all) of the functionality that git implements has been integrated into the GitHub platform. Let’s go over some of them briefly.\n\n10.2.1 Initialise repository\nThere are a few ways to do this. The simplest is to initialise the repo on GitHub then clone it down to your machine. The preferred way to to start with pre-existing local work (repo) and connect it with a remote on GitHub.\n\n10.2.1.1 Initialise on GitHub\nYou can achieve this directly from any page.\n\n\n\nGitHub initialise new remote repository\n\n\nThe configuration is largely self-explanatory.\n\n\n\nConfigure the repository\n\n\nAnd then you are taken to your new shiny repository page.\n\n\n\nNew repository page\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe easiest (but not necessarily the best) way to collaborate via GitHub is to add collaborators to your repository. By adding collaborators, you are giving people read/write access to your repository. It is your responsibility to make sure you are confident that they know what they are doing.\nThe topic of pull requests (see later) introduce a mechanism that in part mitigates some of the risks associated with collaborative repositories.\n\n\n\n\n\nCollaborators setting\n\n\n\n\n\nEnter collaborator details\n\n\nAnd if you want to change the visibility (public/private) of the repository it is down at the bottom of the general settings under the Dange Zone section.\n\n\n10.2.1.2 Initialise from existing repository\nAgain, you can achieve this directly from any page.\n\n\n\nGitHub initialise new remote repository\n\n\nThe only difference in the setup is that you do NOT to initialize the repository with a readme. You will then be shown the following instructions. The latter case is the one that is applicable, as shown.\n\n\n\nLink a local repo with the new remote\n\n\nIf you recall from the previous discussion on fileserver remotes, we had set the remote for the first-repo repository to be a OneDrive remote. Recapping:\n\npwd\n## /Users/mark/Documents/project/misc-stats/first-repo\ngit remote -v\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nWhile we can technically have multiple remotes, it might be easier to simply unlink from this current remote.\n\ngit remote rm origin\ngit remote -v\n## \n\nAnd now add GitHub as the new remote.\n\ngit remote add origin https://github.com/maj-biostat/demo2.git\ngit branch -M main\ngit push -u origin main\n\n## Enumerating objects: 68, done.\n## Counting objects: 100% (68/68), done.\n## Delta compression using up to 8 threads\n## Compressing objects: 100% (67/67), done.\n## Writing objects: 100% (68/68), 6.51 KiB | 3.25 MiB/s, done.\n## Total 68 (delta 41), reused 0 (delta 0), pack-reused 0\n## remote: Resolving deltas: 100% (41/41), done.\n## To https://github.com/maj-biostat/demo2.git\n##  * [new branch]      main -&gt; main\n## branch 'main' set up to track 'origin/main'.\n\n\n\n\n\n\n\nNote\n\n\n\nThe git branch -M main simply renames the current branch to main. In practice, this isn’t a problem if you create all of your repositories with a default branch called main instead of master which is the legacy git preferred name.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe git push -u pushes up the branch information and the evolution of the repository. The -u is bsically telling git to link your local main branch with the remote main branch. You only need to use this flag once and thereafter you can use git fetch and git push and git will know which remote you want to communicate with.\n\n\nWhen we refresh the github page https://github.com/maj-biostat/demo-02 (replacing my username with your own) then we see that the first-repo now appears on GitHub. It doesn’t matter that the remote repo is called something other than first-repo. Generally you will give things the same names, but not always.\n\n\n\nfirst-repo is now on GitHub\n\n\n\n\n\n10.2.2 Clone a GitHub remote\nIn the first approach to initialising a remote (Section 10.2.1.1) we did not bring the remote down to the local machine. However, this is fairly trivial process to achieve by using git clone in a similar manner to how we used it previously.\nNavigate back to the demo-01 repository on GitHub, select the green clone button and copy the link to your clipboard.\n\n\n\nCloning from GitHub\n\n\nNow head back to your terminal, change directory out of first-repo into the local workshop directory and run the following which clones the demo-01 repository to a local directory named demo-01.\n\n\n\n\n\n\nNote\n\n\n\nLocally, you can give the remote repository any name you want. Here we have just used the same repository name as the remote, but we could call it my-demo-01 or anything else you want.\n\n\n\ngit clone https://github.com/maj-biostat/demo-01.git demo-01\n## Cloning into 'demo-01'...\n## remote: Enumerating objects: 3, done.\n## remote: Counting objects: 100% (3/3), done.\n## remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\n## Receiving objects: 100% (3/3), done.\ncd demo-01/\nls -la\n## total 8\n## drwxr-xr-x  10 mark  staff  320  9 Nov 13:29 ..\n## drwxr-xr-x   4 mark  staff  128  9 Nov 13:29 .\n## -rw-r--r--   1 mark  staff   24  9 Nov 13:29 README.md\n## drwxr-xr-x  12 mark  staff  384  9 Nov 13:29 .git\n\n\n\n10.2.3 Fetch and push\nOnce you have linked your local and remote repositories, the workflow is identical to what has been previously introduced.\nLet’s work through the process again.\nFollowing best practice, prior to making a change we create a feature branch and then switch to that branch.\n\ngit branch dev-01\ngit checkout dev-01\n## Switched to branch 'dev-01'\n\nRather than code something up, simply download the random-numbers.R script (also listed on resources, Chapter 14 page) and save it to the demo-01 repository folder on your machine. Run the script with Rscript random-numbers.R to make sure that it works.\n\nRscript random-numbers.R\n##         categorical      normal     gamma poisson\n## Min.             -3 -3.56987408 0.0329983    3.00\n## 1st Qu.          -2 -0.56524365 0.2845135    8.00\n## Median            0  0.03029335 0.7235894    9.00\n## Mean              0  0.07900788 1.0749329    9.82\n## 3rd Qu.           2  0.74139889 1.3816200   12.00\n## Max.              3  3.18586281 5.3176913   20.00\n\nNow make an arbitrary change to the README.md file then stage and commit the files to the dev-01 branch.\n\ngit status\n## On branch dev-01\n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   README.md\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  random-numbers.R\ngit add README.md random-numbers.R\ngit status\n## On branch dev-01\n## Changes to be committed:\n##   (use \"git restore --staged &lt;file&gt;...\" to unstage)\n##  modified:   README.md\n##  new file:   random-numbers.R\ngit commit -m \"Development for demo-01 project\"\n## [dev-01 fc5f874] Development for demo-01 project\n## 2 files changed, 12 insertions(+), 1 deletion(-)\n\nSwitch back to the main branch and get ready to merge your piece of work into the local main branch1.\n\ngit checkout main\n\nLooking at the logs, you can see the dev-01 branch is one step ahead of what we are currently viewing in our working directory.\n\ngit log --oneline --decorate --graph --all\n## * fc5f874 (dev-01) Development for demo-01 project\n## * 809fe51 (HEAD -&gt; main, origin/main, origin/HEAD) Initial commit\n\nand the working directory reflects this reality as only the READ.md file currently exists.\n\nls -la\n## total 8\n## drwxr-xr-x   4 mark  staff  128 10 Nov 11:44 .\n## drwxr-xr-x  10 mark  staff  320 10 Nov 09:19 ..\n## drwxr-xr-x  13 mark  staff  416 10 Nov 11:44 .git\n## -rw-r--r--   1 mark  staff   26 10 Nov 11:44 README.md\n\nMerge the dev-01 branch into main\n\ngit merge dev-01\n## Updating 809fe51..fc5f874\n## Fast-forward\n##  README.md        |  2 +-\n##  random-numbers.R | 11 +++++++++++\n##  2 files changed, 12 insertions(+), 1 deletion(-)\n##  create mode 100644 random-numbers.R\n\nWe now have all the files and updates:\n\nls -la\n## total 16\n## drwxr-xr-x   5 mark  staff  160 10 Nov 11:49 .\n## drwxr-xr-x  10 mark  staff  320 10 Nov 09:19 ..\n## drwxr-xr-x  14 mark  staff  448 10 Nov 11:49 .git\n## -rw-r--r--   1 mark  staff   66 10 Nov 11:49 README.md\n## -rw-r--r--   1 mark  staff  203 10 Nov 11:49 random-numbers.R\n\nAnd the logs indicate that we are now up to date (note the location of HEAD)\n\ngit log --oneline --decorate --graph --all\n## * fc5f874 (HEAD -&gt; main, dev-01) Development for demo-01 project\n## * 809fe51 (origin/main, origin/HEAD) Initial commit\n\nIn this case, we know there have been no changes to the remote during the time where we were doing our development. However, in most collaborative projects, you cannot guarantee this, so we would run a git fetch followed by a git merge to merge any changes that had been pushed to the remote by our collaborators. Finally, we push our updates to the remote, remembering to use the -u flag on this first occasion.\n\ngit push -u origin main\n## Enumerating objects: 6, done.\n## Counting objects: 100% (6/6), done.\n## Delta compression using up to 8 threads\n## Compressing objects: 100% (4/4), done.\n## Writing objects: 100% (4/4), 513 bytes | 513.00 KiB/s, done.\n## Total 4 (delta 0), reused 0 (delta 0), pack-reused 0\n## To https://github.com/maj-biostat/demo-01.git\n##    809fe51..fc5f874  main -&gt; main\n## branch 'main' set up to track 'origin/main'.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you wish to push all branches (i.e. both main and dev-01) in this case then you would need to add the --all flag to the git push. In the present example, this would push all the branches up to the remote. All people reviewing the remote can then review the complete history should they need to.\n\n\n\ngit push --all\n## Total 0 (delta 0), reused 0 (delta 0), pack-reused 0\n## remote:\n## remote: Create a pull request for 'dev-01' on GitHub by visiting:\n## remote:      https://github.com/maj-biostat/demo-01/pull/new/dev-01\n## remote:\n## To https://github.com/maj-biostat/demo-01.git\n##  * [new branch]      dev-01 -&gt; dev-01\n\nAnd the change can be observed once the GitHub page is refreshed.\n\n\n\nUpdated files pushed to GitHub\n\n\n\n\n10.2.4 Reviewing history\nGitHub provides an interface to review the changes that have occurred on the repo. Clicking on a file within your repository will take you to the file history page where you can review the evolution of the file.\n\n\n\nUpdated readme and pushed to GitHub\n\n\nOnce the history page opens you can navigate to various versions of a file. One the left you can select the branch of interest (here main is shown). You can view the code or the commit with syntax highlighting or in raw form (which also lets you copy and paste the raw text should you need it). Over on the right are the latest commit point and an open to review the full timeline (History).\n\n\n\nFile review\n\n\nWhen you review the blame view, you can see determine who did what and when.\n\n\n\nCode associated with commits\n\n\n\n\n10.2.5 Issues\nIssues can be managed directly within GitHub, although they are repository specific. Currently, our team mostly uses Jira to track and manage issues and therefore I will not cover the GitHub functionality beyond mentioning that it is very straight forward to use.\nOne instance where you may be required to use GitHub issue functionality is when you find a bug in a CRAN package, e.g. https://github.com/rstudio/gt/issues/1415. When doing so, you will find that they require a particular protocol to be followed that include the development of a minimal working example. This is standard practice in software development, it makes a developers life much easier and it is more likely that the problem you are reporting will actually get fixed."
  },
  {
    "objectID": "notebooks/github-101.html#exercises",
    "href": "notebooks/github-101.html#exercises",
    "title": "10  GitHub introduction",
    "section": "10.3 Exercises",
    "text": "10.3 Exercises\n\nExercise 10.1 When creating a new branch, we have needed to take to steps. First, we created the branch and then we checked it out. Is there a way this can be done with one command? Hint - Yes What is that command?"
  },
  {
    "objectID": "notebooks/github-101.html#footnotes",
    "href": "notebooks/github-101.html#footnotes",
    "title": "10  GitHub introduction",
    "section": "",
    "text": "I know this is a bit artificial, but it is just for practice↩︎"
  },
  {
    "objectID": "notebooks/part-03.html",
    "href": "notebooks/part-03.html",
    "title": "Part 3 - Collaboration",
    "section": "",
    "text": "This part is about how we use git to collaborate. It is probably the toughest part and so we will just cover the basics. I will\n\nIntroduce fileserver backed git remotes\nGitHub collaboration processes\nDocumentation backed by GitHub"
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#sec-no-github",
    "href": "notebooks/git-collab-fileserver.html#sec-no-github",
    "title": "11  Collaboration 101",
    "section": "11.1 No github?",
    "text": "11.1 No github?\nGitHub is a hosting service for git repositories. It also extends some of the git functionality. They have captured the market, mainly because we are all a bit dim.\nBefore 2005 (ish), GitHub did not exist, and it wasn’t a catastrophe. What did we do? Git has the functionality built into it to allow collaboration via hosting git repositories directly on fileservers. This is a reasonable solution for small teams with access to a common network, but it has its limitations. Nevertheless, most bluechip organisations used this approach during the 2000’s.\nRepositories that are retained outside of your local machine are referred to as remotes. It doesn’t matter whether they are hosted on LIQUID, or a random file server or GitHub or BitBucket or Timbuktu. They are still known as remotes.\nRemotes allow you to work on a repository collaboratively with your colleagues. This has been standard practice in software development since circa 1760.\nWe will talk about hosting remotes on fileservers here and then move on to GitHub next."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#so-remote",
    "href": "notebooks/git-collab-fileserver.html#so-remote",
    "title": "11  Collaboration 101",
    "section": "11.2 So remote",
    "text": "11.2 So remote\nWhat remote (or remotes) are associated with the example repository that we have been working on? Let’s look.\n\ngit remote -v\n\nNo remotes.\nIf at any time you want to review the remotes associated with your repository (you can have more than one remote) then invoke the command that we just used."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#initialising-remotes",
    "href": "notebooks/git-collab-fileserver.html#initialising-remotes",
    "title": "11  Collaboration 101",
    "section": "11.3 Initialising remotes",
    "text": "11.3 Initialising remotes\nLet’s set up a remote on OneDrive. OneDrive is a cloud file-server, but technically we could replace OneDrive with any file-server. For example, we used to have the LIQUID drive at TKI mounted as a network drive and we could use that.\nAnyway, just follow along.\n\ngit clone --bare first-repo /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\n\nWhy USyd (or Microsoft) uses such ludicrous names for their software is beyond me.\nThe above takes the repository that we have been working on and moves the git database to OneDrive. If we look at OneDrive then we see:\n\npwd\n## /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\nls -lrta\n## total 48\n## drwx------@  20 mark  staff   640  8 Nov 08:36 ..\n## -rw-r--r--    1 mark  staff    73  8 Nov 08:36 description\n## -rw-r--r--    1 mark  staff   188  8 Nov 08:36 config\n## -rw-r--r--    1 mark  staff   618  8 Nov 08:36 packed-refs\n## -rw-r--r--    1 mark  staff    21  8 Nov 08:36 HEAD\n## drwxr-xr-x@  11 mark  staff   352  8 Nov 08:36 .\n## drwxr-xr-x    3 mark  staff    96  8 Nov 08:36 info\n## drwxr-xr-x   16 mark  staff   512  8 Nov 08:36 hooks\n## drwxr-xr-x  105 mark  staff  3360  8 Nov 08:36 objects\n## drwxr-xr-x    5 mark  staff   160  8 Nov 08:36 refs\n## -rw-r--r--@   1 mark  staff  6148  8 Nov 08:36 .DS_Store\n\nThe first thing to note is that there is no working directory.\nNow let’s imagine that I Sylvie has just joined the team as naive Bayesian statistician. Sylvie needs to start work on the first-repo project. First, we need to get the repository onto her local machine.\nThe process is as follows.\n\nGo to you Documents folder (or wherever you intend to store your projects)\nClone the remote\n\nObviously, I am working off a single laptop clone the repo to some alternative name. I will refer to this location as Sylvie’s repo vs Mark’s repo which is the one that I have been referencing when demonstrating examples.\nIn contrast to the bare repository remote, we (Sylvie) now has the example files that we have been developing to date.\n\n\n\n\n\n\nNote\n\n\n\nNote that I called the repo sylvie-first-repo. We can call the local version of the repo whatever we want.\n\n\n\ncd /Users/mark/Documents/\ngit clone /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git sylvie-first-repo\nls -lrta\n## total 40\n## drwxr-xr-x   3 mark  staff    96  8 Nov 11:07 ..\n## -rw-r--r--   1 mark  staff   100  8 Nov 11:07 .gitignore\n## -rw-r--r--   1 mark  staff  2274  8 Nov 11:07 branching.R\n## -rw-r--r--   1 mark  staff   242  8 Nov 11:07 hello.R\n## -rw-r--r--   1 mark  staff    38  8 Nov 11:07 myscript.R\n## drwxr-xr-x   8 mark  staff   256  8 Nov 11:07 .\n## -rw-r--r--   1 mark  staff   138  8 Nov 11:07 readme.md\n## drwxr-xr-x  12 mark  staff   384  8 Nov 11:07 .git\n\nLook at the details of the remote associated with Sylvie’s repo:\n\ncd /Users/mark/Documents/sylvie-first-repo/\ngit remote -v\norigin  /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\norigin  /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nThe picture now looks like this\n\n\n\nClone repository\n\n\nOver on the left we have the remote git database. On the right we have Mark who created the remote from his local repository and Sylvie who cloned the remote repository to her local machine. Git isn’t restricted to this centralised architecture (it is possible to have multiple remotes and other variations) but it is a common paradigm.\nGitHub uses a different workflow that commonly relies on a project owner pulling a developers updates into a main project repository rather than the developer pushing their work directly to the project repository. We will see more about this later."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#keeping-remotes-up-to-date",
    "href": "notebooks/git-collab-fileserver.html#keeping-remotes-up-to-date",
    "title": "11  Collaboration 101",
    "section": "11.4 Keeping remotes up to date",
    "text": "11.4 Keeping remotes up to date\nFor now, you can think of a remote as the hub around which collaboration revolves. As a project progresses, the local files are updated and we need to get these files into the remote so that our colleagues can keep their work in sync. However, someone else may send their files to the remote prior to you completing your work.\nThis would mean that the state of the remote is ahead of your local repository.\ngit (and GitHub) will not allow you to send your updates to the repository unless you are sync’d. In other words, you have to be up to date in order to send your changes to the remote.\nTo be able to push your work up to the remote, the steps are:\n\nensure that all your changes are committed to the local repository\nrun git fetch to establish whether you are up to date with the remote\nif necessary, merge any changes into your local repository to get up to date\nensure that all your changes are committed to the local repository\ngit push you modifications up to the remote\n\nHere is another picture.\n\n\n\nCentralised workflow\n\n\nIt sounds (and looks) a bit involved, but in practice it is simple. We will go over the steps below.\n\n11.4.1 Fetch and push (simple case)\nFirst Silvie ensures that all her local changes are committed to the repository. It looks like Silvie made a change to the readme.md when we were not looking.\n\ncd sylvie-first-repo\ngit status\n## On branch main\n## Your branch is up to date with 'origin/main'.\n## \n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   readme.md\n## \n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\ngit add readme.md; git commit -m \"Minor change for testing fetch\"\n\nNo changes have been made to the remote by anyone else so when we run git fetch there is no response. Therefore we can go and push the changes.\n\ngit push\n## Enumerating objects: 5, done.\n## Counting objects: 100% (5/5), done.\n## Delta compression using up to 8 threads\n## Compressing objects: 100% (3/3), done.\n## Writing objects: 100% (3/3), 342 bytes | 342.00 KiB/s, done.\n## Total 3 (delta 2), reused 0 (delta 0), pack-reused 0\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##    7eee4b5..49225cc  main -&gt; main\n\n\n\n\n\n\n\nNote\n\n\n\nThe examples under the git push man page are helpful and informative for further detail on the interpretation of git push.\n\n\nLooking at the logs we see the following\n\ngit log --oneline\n## 3a3dd8d (HEAD -&gt; main, origin/main, origin/HEAD) Testing Sylvie\n## 2829471 Merge branch 'analysis-03'\n## be09457 (tag: v3.0, origin/analysis-03) Finished surv\n## 53115b6 minor\n## 7a5e7b9 Surv analysis\n## 1a9dfeb (tag: v2.0) Edits from code review\n## d1586df Completion of secondary analysis\n## bf34b9c Merge from fix-01\n## b8de16c (tag: v1.1, origin/fix-01) Edits from code review\n## 12561d9 Emergency fix\n## d88f9e5 WIP\n## a2cc6f7 (tag: v1.0) Comments from code review\n## fa24778 branching.R\n## 3bdac46 Revised approach to capturing input\n## 327170a Minor edit\n## b078716 New file\n## 0cd2d52 First commit\n\n\n\n11.4.2 Fetch and push (merge required)\nIn the interim Mark has been working on the first-repo and will want to get these changes into the remote. However, Mark hasn’t yet linked his local repository with the remote.\n\ngit remote -v\n## nothing\n\nTo fix this we use git remote add which, predictably tells git to configure a link between a local and remote version of the repository. This is a one time process and once we have set the remote, we do not need to do it again until we need to add a new remote.\n\ngit remote add origin /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\ngit remote -v\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\n\n\n\n\n\n\nNote\n\n\n\nThe use of the word origin below is just convention to indicate the primary remote. It is a shortcut for the full directory path (or URL) for the remote. You can call the remote anything you want but most people stick with the convention of origin, which is a bit like the GitHub convention of using main for the main branch. If you were to add a second remote, you would call it something other than origin.\n\n\nNext, we need to tell the local repository to reference this remote.\n\ngit remote add origin /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\ngit remote -v\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nWe see that the remote has been added for both push and fetch. Before we use these, we need to make an existing local branch track a specific remote branch which is achieved with\n\ngit fetch  # pulls down information on the branches in the remote\ngit branch --set-upstream-to=origin/main main # links a local with remote branch\n\nChecking the status we see that the change that Sylvie pushed has left us out of sync.\n\ngit status\n## On branch main\n## Your branch and 'origin/main' have diverged,\n## and have 1 and 1 different commits each, respectively.\n##   (use \"git pull\" if you want to integrate the remote branch with yours)\n## \n## nothing to commit, working tree clean\n\nIf I try to push my change anyway, git barfs:\n\ngit push\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##  ! [rejected]        main -&gt; main (non-fast-forward)\n## error: failed to push some refs to '/Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git'\n## hint: Updates were rejected because the tip of your current branch is behind\n## hint: its remote counterpart. If you want to integrate the remote changes,\n## hint: use 'git pull' before pushing again.\n## hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\nThis is what I was referring to earlier. Git will not allow you to screw up the remote without some strenous effort on your part. It would be nice if git had told us what was different, but it forces us to do this via the following:\n\ngit fetch # this was done previously, but just to be clear that you need to do a fetch first\ngit diff main origin/main\n## diff --git a/readme.md b/readme.md\n## index 0165627..797358c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,7 +4,9 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## -Contains standalone R scripts for staged deliverables to client.\n## +Contains standalone R scripts.\n## +\n## +Test by Sylvie\n\nYou can see the line that I introduced and also the change that Sylvie added and committed to the remote. There are a few options to resolve this. Most people use git pull which runs a two-step process. In my opinion, while this is convenient, it can get you in to trouble. It is generally safer to split the process up into a fetch and then a merge.\n\ngit fetch\ngit merge\n## Auto-merging readme.md\n## Merge made by the 'ort' strategy.\n##  readme.md | 3 +++\n##  1 file changed, 3 insertions(+)\n\n\n\n\n\n\n\nNote\n\n\n\nGit offers another command git pull that effectively combines git fetch with git merge. The benefit of using git fetch is that it will update your local repository but will not make any changes to your working directory (see Section 5.1.2.1 for a reminder).\n\n\nAnd in this case, the merge appears to have worked correctly.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nA new line for testing.\n\nContains standalone R scripts for staged deliverables to client.\n\nTest by Sylvie"
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#remotes-and-branches",
    "href": "notebooks/git-collab-fileserver.html#remotes-and-branches",
    "title": "11  Collaboration 101",
    "section": "11.5 Remotes and branches",
    "text": "11.5 Remotes and branches\nOne key aspect that I have not mentioned to date is for the scenario where new branches are created in a local repository.\nTo list all known branches in both your local repository and the remote (or remotes)\n\ngit branch -a\n##   analysis-03\n##   fix-01\n## * main\n##   remotes/origin/analysis-03\n##   remotes/origin/fix-01\n##   remotes/origin/main\n\nLet’s say that Mark is asked to develop a new analysis. Learning from past mistakes, he creates an analysis-04 branch and adds the following content to run a non-parameteric surivival analysis.\n\ngit branch analysis-04\n\nTo complete the analysis, the following is added to the branching.R script, which is tested, staged and committed.\n\nmessage(\"\\n\\nANALYSIS OF SURVIVAL OUTCOME (UNSTRATIFIED, NON-PARAMETRIC):\\n\")\n\nlm4 &lt;- survdiff(Surv(w, evt) ~ x, data = d)\nprint(lm4)\n\nFollowing the earlier process, Mark then switches back to main and merges in the new analysis.\n\ngit checkout main\ngit merge analysis-04\n\nand then pushes the change up to the remote repository.\n\ngit push\n\nUnfortunately, this does not establish the analysis-04 branch within the remote. This may or may not be a problem (usually not) but it is worth being aware of, because other users will not be able to get access to the evolution of the files that occurred on the development branch. To push the analysis-04 branch we use:\n\ngit push --set-upstream origin analysis-04\n## Total 0 (delta 0), reused 0 (delta 0), pack-reused 0\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##  * [new branch]      analysis-04 -&gt; analysis-04\n## branch 'analysis-04' set up to track 'origin/analysis-04'.\n\nAnd now uses can fetch and review this branch within the context of their local repositories."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#comparing-differences",
    "href": "notebooks/git-collab-fileserver.html#comparing-differences",
    "title": "11  Collaboration 101",
    "section": "11.6 Comparing differences",
    "text": "11.6 Comparing differences\nTODO - Using the .. notation."
  },
  {
    "objectID": "notebooks/git-collab-github.html#footnotes",
    "href": "notebooks/git-collab-github.html#footnotes",
    "title": "12  Collaboration with GitHub",
    "section": "",
    "text": "Yes, you can fork your own repos, although a template repository might be more suitable depending on your goals.↩︎"
  },
  {
    "objectID": "notebooks/part-04.html",
    "href": "notebooks/part-04.html",
    "title": "Part 4 - Other bits",
    "section": "",
    "text": "Here are some additional bits that I did not know where to put anywhere else."
  },
  {
    "objectID": "notebooks/resources.html",
    "href": "notebooks/resources.html",
    "title": "14  Resources",
    "section": "",
    "text": "These files are used in Part 2 - Fundamentals from the text:\n\nhello.R\nreadme.md\nbranching.R\n.gitignore\nrandom-numbers.R\n\nThese files are used in Part 3 - Collaboration from the text:\n\nNone currently required."
  },
  {
    "objectID": "notebooks/common-commands.html",
    "href": "notebooks/common-commands.html",
    "title": "15  Common commands",
    "section": "",
    "text": "todo"
  },
  {
    "objectID": "notebooks/about.html#repository-status",
    "href": "notebooks/about.html#repository-status",
    "title": "About",
    "section": "Repository status",
    "text": "Repository status\nDetails on github repository files, tags, commits follow:\n\nrepo &lt;- git2r::repository(path = \".\")\nsummary(repo)\n\nLocal:    main /Users/mark/Documents/project/misc-stats/get-going-with-git\nRemote:   main @ origin (https://github.com/maj-biostat/get-going-with-git)\nHead:     [ba0a5af] 2023-11-16: Editorial\n\nBranches:         2\nTags:             1\nCommits:         50\nContributors:     2\nStashes:          0\nIgnored files:    5\nUntracked files: 28\nUnstaged files:   0\nStaged files:     0\n\nLatest commits:\n[ba0a5af] 2023-11-16: Editorial\n[cfc6bfe] 2023-11-15: Start on gh pages\n[024b82f] 2023-11-15: Start on CLI for gh\n[ae66b7b] 2023-11-15: Minor edit\n[641d8d0] 2023-11-15: Editing, clarifying narrative\n\n\nTodo:\ntracked common commands doco link overleaf\nprep notes"
  }
]