[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Get going with git",
    "section": "",
    "text": "Introduction\nWhen you are getting into the nitty gritty, version control is a large topic. The git, github, github cli and github pages ‚Ä¶ technologies can be daunting to set up and use. However, once you are setup properly and understand how things fit together at a high level, users can go a long way with a minimal set of commands.\nI know, it is true that a little knowledge can be a dangerous thing, but it probably isn‚Äôt quite as bad as complete ignorance.\nGet going with git - aims to provide a minimal knowledge base, sufficient to get you started without having to wade through reams of documentation distributed all over the internet. It can be browsed online or downloaded as a word document for your reference.\nWhat is version control? Setting up git Time to commit: working with a local repository Push and pull: working with a remote repository Making your first repository on GitHub Day 2: Collaborating with Others\nDealing with (git) conflicts Branching for sanity Creating pull requests Collaborating with GitHub tools Day 3: Dealing with Complications\nUndoing changes Learning good repository organization principles Ignoring things (in git) Working with large files Using the README Creating GitHub templates Extending git and GitHub with other tools"
  },
  {
    "objectID": "notebooks/preamble.html#background-reading",
    "href": "notebooks/preamble.html#background-reading",
    "title": "Pre-requisites",
    "section": "Background reading",
    "text": "Background reading\nThere is no point reinventing the wheel, Jenny Bryant motivates the use of version control in the following paper: Excuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/preamble.html#objectives",
    "href": "notebooks/preamble.html#objectives",
    "title": "Pre-requisites",
    "section": "Objectives",
    "text": "Objectives\nNote that you are likely to find some of this course hard and/or frustrating. I have purposefully taken a low level perspective on git because it is the best way to get a clear picture of what is actually happening.\nThink of it this way, if you didn‚Äôt understand what letters and words are, you are probably going to have a hard job of understanding how to cunstrucked a sentunse1.\nPeople get themselves in a mess often simply as a result of not understanding the fundamentals. Therefore, the goal here is to understand the fundamental aspects of revision control and git in particular. Once you have that base, extending from there will be much easier for you.\nThe pace of the workshop will be based on the abilities of the audience but there is an expectation that the audience practices the skills. The workshop is likely to be run over a few sessions but the exact length is yet to be determined."
  },
  {
    "objectID": "notebooks/preamble.html#command-line-interfaces",
    "href": "notebooks/preamble.html#command-line-interfaces",
    "title": "Pre-requisites",
    "section": "Command line interfaces",
    "text": "Command line interfaces\nA CLI is a software mechanism that you use to interact with your operating system via your keyboard rather than a mouse. You enter in commands as text and the system will do something, e.g.¬†delete a file.\nCLIs are software that are supplied with the operating system. Software that implements such a text interface is often called a command-line interpreter, command processor or a shell.\nNearly universally, if I use the word terminal I am referring to the operating system command line interface.\nWindows refers to its CLI as the command prompt, and in macOS we have the terminal.\nIf you do not know how to operate your operating system CLI then you need to address that.\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nHow to use Windows 10‚Äôs Command Prompt\nLearning Windows Terminal\n\nThe following link needs admin rights (TKI people probably won‚Äôt have nor will be able to obtain these rights) and is not strictly necessary here, but it gives a lot of useful commands and an opportunity to gain a bit more familiarity with the commandline.\n\n40 Windows Commands you NEED to know\n\n\n\nmacOS\n\nHow To Use Terminal On Your Mac\nWhat Is the Mac Terminal?\nAbsolute BEGINNER Guide to the Mac OS Terminal\n\n\n\nExtra credit\n\nLearn the command line"
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management---environment-variables",
    "href": "notebooks/preamble.html#operating-system-management---environment-variables",
    "title": "Pre-requisites",
    "section": "Operating system management - environment variables",
    "text": "Operating system management - environment variables\nYou will need to have some minimal technical competence in driving your computer. At a minimum, you need to know how to set an environment variable under your operating system of choice. If you do not know how to set an environment variable, then you need to address that.\nOther items that are important to be familiar with are file and directory concepts. For example, if you do not know what the command tree does, then it would be useful to find out. Similarly, if you do not know what file permissions are then, again, it would be useful to find out.\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nEnvironment Variables : Windows 10\nHow to Set Environment Variables in Windows 11\n\nyou should be able to set a user variable even if you do not have admin priviledges.\n\n\nmacOS\n\nHow to Set Environment Variables in MacOS\nPATH Variable (Mac)\nUse environment variables in Terminal on Mac"
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management",
    "href": "notebooks/preamble.html#operating-system-management",
    "title": "Pre-requisites",
    "section": "Operating system management",
    "text": "Operating system management\nCreate a directory on your machine where we will store all the files for this workshop.\nSimply go to the your Documents directory and create a sub-dir called get-going-with-git.\nThroughout this text, if I say go to your local workshop directory, this is the location I want you to go to."
  },
  {
    "objectID": "notebooks/preamble.html#github",
    "href": "notebooks/preamble.html#github",
    "title": "Pre-requisites",
    "section": "GitHub",
    "text": "GitHub\nFollow part 1 of the instructions provided by Getting started with your GitHub account to create and configure your account.\n\n\n\n\n\n\nWarning\n\n\n\nThe part on configuring 2-factor authentication is absolutely mandatory, the rest of the 2-factor content can be skimmed. See Configuring two-factor authentication.\n\n\nTo use the USyd GitHub Enterprise Server, you will need a unikey. If you have a unikey, you should have access. Go here and confirm that you can login."
  },
  {
    "objectID": "notebooks/preamble.html#onedrive",
    "href": "notebooks/preamble.html#onedrive",
    "title": "Pre-requisites",
    "section": "OneDrive",
    "text": "OneDrive\nYou will need to install the desktop application for OneDrive so that you have file system integration (i.e.¬†so that you can see your OneDrive through your file explorer app).\nYou may need to go to IT Support to get them to install OneDrive for you, but it may already be installed."
  },
  {
    "objectID": "notebooks/preamble.html#footnotes",
    "href": "notebooks/preamble.html#footnotes",
    "title": "Pre-requisites",
    "section": "",
    "text": "Yes, intentional :)‚Ü©Ô∏é"
  },
  {
    "objectID": "notebooks/part-01.html",
    "href": "notebooks/part-01.html",
    "title": "Part 1 - Logistical elements",
    "section": "",
    "text": "In this part we will get everything set up. This may well be the hardest part."
  },
  {
    "objectID": "notebooks/resources.html",
    "href": "notebooks/resources.html",
    "title": "1¬† Resources",
    "section": "",
    "text": "These files are used in Part 2 - Fundamentals from the text:\n\nhello.R\nreadme.md\nbranching.R\n.gitignore"
  },
  {
    "objectID": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "href": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "title": "2¬† What is (this thing) called revision control",
    "section": "2.1 The big picture",
    "text": "2.1 The big picture\nFirst, let‚Äôs briefly introduce some minimal terminology and context.\n\n\n\n\n\n\nNote\n\n\n\nTODO - Timelines\n\n\nA repository is the mechanism that is used to implement version control by git.\n\n\n\n\n\n\nNote\n\n\n\nThe repository is implemented by a hidden directory called .git that exists within the project directory and contains all the data on the changes that have been made to the files in the project. You should never touch this directory nor its contents.\n\n\nThere are two types of repositories, local and remote.  The local repositories reside on your machine. Remote repositories are hosted by service providers, the most common being GitHub, GitLab and Bitbucket. We only deal with GitHub here. GitHub comes in a few varieties:\n\nGitHub Enterprise is hosted by the company called GitHub, see github.com. It is a commercial platform, but parts of it are made freely available.\nGitHub Enterprise Server is self-hosted; this is what USyd provides via https://github.sydney.edu.au/\n\nIn a nutshell, git provides a set of commands that allow you to manage the files that are retained in these local and remote repositories.\nAgain, I cannot sum it up better than Jenny, so please take the time to read it.\nExcuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/what-is-revision-control.html#why-commandline",
    "href": "notebooks/what-is-revision-control.html#why-commandline",
    "title": "2¬† What is (this thing) called revision control",
    "section": "2.2 Why commandline",
    "text": "2.2 Why commandline\nBecause it is the best way."
  },
  {
    "objectID": "notebooks/git-install.html#rstudio",
    "href": "notebooks/git-install.html#rstudio",
    "title": "3¬† Git install",
    "section": "3.1 RStudio",
    "text": "3.1 RStudio\nDevelopers - is your instance of RStudio up to date? If not, update it. Ditto for R. Keep them both updated."
  },
  {
    "objectID": "notebooks/git-install.html#install-git",
    "href": "notebooks/git-install.html#install-git",
    "title": "3¬† Git install",
    "section": "3.2 Install git",
    "text": "3.2 Install git\nI am going to break this down into Mac and Windows because they are the two systems that most of AHI seem to use and the installation is somewhat different for each. If you are using Linux, you probably have no need to be reading this.\n\n3.2.1 Mac OSX\nFirst, do you have git installed already? Launch the terminal app (see the pre-requisites on the landing page if you do not know how to do this). In the terminal, type:\nwhich git\nwhich should show the location of the version of git in use:\n## /opt/homebrew/bin/git\nIf you have homebrew (see below) installed, you can just type:\nbrew install git\nand git will be installed, otherwise, follow the instructions below and then come back here.\nOnce git is installed run the which git command again and then run git --version which is shown (along with the output) below:\ngit --version\n## git version 2.42.0\nIf you got here, then you have git installed. You can close down terminal, open it up again and then run the git --version command again to make certain that everything is ok.\n\n\n3.2.2 Homebrew\nIn the previous section, you can see that the path output from the which git command includes homebrew. For macOS, homebrew is a package manager. This basically just lets you install and manage packages (applications) on your mac.\nTo use homebrew, you need to install it first. To do that, go here, then follow the instructions, which amount to going to the terminal and running the commands listed below.\nPlease go and read the landing page for homebrew before you proceed any further.\nThe first command ensures that pre-requisites are met, see here:\n xcode-select --install\nif this has already been doing you will get an error, or be asked to run Software Update. Generally, you can just move on to the next command:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\ncurl is a tool for transferring data from a url. It is usually stored under /usr/bin but if you are having issues then exporting the following might assist:\nexport HOMEBREW_FORCE_BREWED_CURL=1\nwhich basically tells homebrew to use its own version of curl. After the above is complete, homebrew should be installed. Now you can run\nbrew install git\nto install git for you.\nFor reference, here are a minimal set of commands for using homebrew (additional information can be found in the homebrew man pages).\nBasic information on homebrew:\n# Display the version of Homebrew.\n$ brew --version\n# Print Help Information\n$ brew help\n# Print Help Info for a brew command\n$ brew help &lt;sub-command&gt;\n# Check system for potential problems.\n$ brew doctor\nKeep your homebrew applications up to date:\n# Fetch latest version of homebrew and formula\n$ brew update\n# Show formulae with an updated version available\n$ brew outdated\n# Upgrade all outdated and unpinned brews\n$ brew upgrade\n# Upgrade only the specified brew\n$ brew upgrade &lt;formula&gt;\n# Prevent the specified formulae from being upgraded\n$ brew pin &lt;formula&gt;\n# Allow the specified formulae to be upgraded.\n$ brew unpin &lt;formula&gt;\nThe core commands for managing commandline applications are:\n# List all the installed formulae.\n$ brew list\n# Display all locally available formulae for brewing.\n$ brew search\n# Perform a substring search of formulae names for brewing.\n$ brew search &lt;text&gt;\n# Display information about the formula.\n$ brew info &lt;formula&gt;\n# Install the formula.\n$ brew install &lt;formula&gt;\n# Uninstall the formula.\n$ brew uninstall &lt;formula&gt;\n# Remove older versions of installed formulae.\n$ brew cleanup\nHomebrew casks allow you to install GUI applications. Unless you are an advanced user, you will rarely need to use these, but for completeness:\n# Tap the Cask repository from Github.\n$ brew tap homebrew/cask\n# List all the installed casks .\n$ brew cask list\n# Search all known casks based on the substring text.\n$ brew search &lt;text&gt;\n# Install the given cask.\n$ brew cask install &lt;cask&gt;\n# Reinstalls the given Cask\n$ brew cask reinstall &lt;cask&gt;\n# Uninstall the given cask.\n$ brew cask uninstall &lt;cask&gt;\n\n\n3.2.3 Windows\nThe official site for the git windows binary download is https://git-scm.com/download/win.\nDownload the 64-bit standalone installer, run it, agree to the conditions and license, choose the default location.\nEnsure that the following install components are chosen:\n\nwindows explorer integration\nlarge file support\n\nand accept any other defaults.\nWith the exception of the following, for any of the other prompts, just accept the defaults.\n\nYou will need to nominate a text file editor for editing commit messages and so on. Unless, you know what you are doing, I would advise just select the Windows Notepad application, you can reconfigure this later if you want to.\nYou should select to override the default branch name as main. The reason to do this is so that git aligns with github (which uses main as its default branch).\nFor adjusting the PATH environment variable, ensure that you select Git from the command line and also from 3rd-party software which is the default.\nEnsure that line ending conversion is set to Checkout as-is, commit as-is.\nFor the terminal emulator, select Use Windows default console window. This has some limitations but it is ok for an introduction.\nEnsure that Git Credential Manager Core is selected when prompted.\n\nWe will run through this install for someone in the group.\nTo keep git up to date, you will need to go to the above site and download and reinstall git.\nOpen the command prompt and type:\ngit --version\n## git version 2.42.0"
  },
  {
    "objectID": "notebooks/git-setup.html#configuration-for-git",
    "href": "notebooks/git-setup.html#configuration-for-git",
    "title": "4¬† Git setup",
    "section": "4.1 Configuration for git",
    "text": "4.1 Configuration for git\nPer the sentiment of Fred Basset, you are now up but not quite running.\n\n\n\nFred Basset\n\n\nOne of the first things we need to do is to set a username and email address:\ngit config --global user.name \"Fred\"\ngit config --global user.email \"fred.basset@comic-land.com\"\nYou can list your configuration with\ngit config --global --list\nWe will get into the why later, but basically any interaction you have with git will be tied to your username and email address. This has obvious benefits if we want to be able to figure out who has done what, when and why.\ngit config --global init.defaultBranch \"main\""
  },
  {
    "objectID": "notebooks/github-setup.html#sec-github-setup",
    "href": "notebooks/github-setup.html#sec-github-setup",
    "title": "5¬† Github setup",
    "section": "5.1 GitHub account",
    "text": "5.1 GitHub account\nAs noted in the pre-requisites for using this knowledge base, you have to have GitHub account.\nWhile there are multiple ways to interact with GitHub from your local machine, here we will use the commandline. There are two protocols that can be used, HTTPS and SSH. We will use HTTPS.\nFirst we need to set up a Personal access token.\n\n5.1.1 Personal access token\nGitHub introduced personal access tokens a short while ago. Personal access tokens are basically a password with some bells and whistles.\n\nLogin to your GitHub account.\nOpen Creating a personal access token (classic) in a new tab in your browser and follow the instructions.\nSet the expiry to at least several months into the future."
  },
  {
    "objectID": "notebooks/github-setup.html#git-credential-manager",
    "href": "notebooks/github-setup.html#git-credential-manager",
    "title": "5¬† Github setup",
    "section": "5.2 Git Credential manager",
    "text": "5.2 Git Credential manager\nThe GCM is a platform agnostic credential manager (in English, that translates loosely to a password manager). Once it‚Äôs installed and configured, Git Credential Manager is called by git and you shouldn‚Äôt need to do anything special.\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you‚Äôll also need to complete the 2FA challenge.\nOnce you‚Äôve authenticated successfully, your credentials are stored in the macOS keychain and will be used every time you clone an HTTPS URL. Git will not require you to type your credentials in the command line again unless you change your credentials.\n\n5.2.1 GCM install\nFor Windows users it can be installed by selecting this option during the installation wizard, see Section¬†3.2.3, step 6.\nFor macOS, use homebrew again, specifically:\nbrew install --cask git-credential-manager\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## ############################################################################################################################################## 100.0%\n## ==&gt; Downloading https://github.com/git-ecosystem/git-credential-manager/releases/download/v2.3.2/gcm-osx-arm64-2.3.2.pkg\n## ==&gt; Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/158405551/3b89ee5f-5275-4316-a794-6f39e38849c4?X-Am\n## ############################################################################################################################################## 100.0%\n## ==&gt; Installing Cask git-credential-manager\n## ==&gt; Running installer for git-credential-manager with sudo; the password may be necessary.\n## Password:\n## installer: Package name is Git Credential Manager\n## installer: Installing at base path /\n## installer: The install was successful.\n## üç∫  git-credential-manager was successfully installed!\n\n\n5.2.2 GCM demo\nBelow I demo the process by cloning a private repository from my GitHub account.\n192-168-1-100:tmp mark$ git clone https://github.com/maj-biostat/wisca_2.git\nCloning into 'wisca_2'...\ninfo: please complete authentication in your browser...\nat this point the following window is launch by GCM:\n\n\n\nGCM\n\n\nselecting Sign in with your browser the following will launch in your default browser (Chrome, Safari, etc)\n\n\n\nSign in with browser\n\n\nselecting Authorize git-ecosystem will result in\n\n\n\nSign in with browser\n\n\nat which point you use the 2-factor authenticator tool (I use google authenticator) to respond with an authentication code.\n\n\n\nAuth success\n\n\nLooking back at the terminal, the following output can be observed, which details the repository being cloned.\nremote: Enumerating objects: 297, done.\nremote: Counting objects: 100% (297/297), done.\nremote: Compressing objects: 100% (156/156), done.\nremote: Total 297 (delta 148), reused 284 (delta 137), pack-reused 0\nReceiving objects: 100% (297/297), 7.85 MiB | 2.13 MiB/s, done.\nResolving deltas: 100% (148/148), done.\nFinally, you will receive an email of this sort:\nHey maj-biostat!\n\nA first-party GitHub OAuth application (Git Credential Manager) with gist, repo, and workflow scopes was recently authorized to access your account.\nVisit https://github.com/settings/connections/applications/0120e057bd645470c1ed for more information.\n\nTo see this and other security events for your account, visit https://github.com/settings/security-log\n\nIf you run into problems, please contact support by visiting https://github.com/contact\n\nThanks,\nThe GitHub Team\nOn repeating this process a second time, all the authentication works in the background and there will be no need to go through various authentication handshakes again.\nThe same process applies irrespective of whether you are using GitHub.com or the USyd GitHub Enterprise Server. However, it is adviseable to get this working in GitHub first and then work on getting it to work in the USyd GitHub Enterprise Server.\nThe transition from the old authentication approach has (so far) proved completely seemless for macOS. It will be interesting to see what happens for the Windows platform.\n\n\n5.2.3 GCM configuration (advanced only)\nYou can view the current credential manager by running the following commands:\ngit config --local credential.helper\ngit config --global credential.helper\n# /usr/local/share/gcm-core/git-credential-manager\ngit config --system credential.helper\nOf the local, global and system, the first one checks the local repository config, the second is your ~/.gitconfig, and the third is based on where git is installed. Note that only one credential help is configured in the above example.\nIn some circumstances you may need to reconfigure things. If you have to start from scratch, the following may be useful:\ngit config --local --unset credential.helper\ngit config --global --unset credential.helper\ngit config --system --unset credential.helper\nFor windows uses check the contents of the credential manager. This can be accessed via Control Panel &gt;&gt; All Control Panel Items &gt;&gt; Credential Manager or by simply typing Credential Manager in the Windows task bar. Under generic credentials you should see the git entries."
  },
  {
    "objectID": "notebooks/github-setup.html#github-cli",
    "href": "notebooks/github-setup.html#github-cli",
    "title": "5¬† Github setup",
    "section": "5.3 GitHub CLI",
    "text": "5.3 GitHub CLI\nIn the day to day grind, having to deal with GitHub through its Web interface can be a little cumbersome. You can obviate having to interact with GitHub through the browser by using the GitHub CLI. This tooling allows you to review, create and manage your repositories from the comfort of your commandline. You can think of it as an extension of git that allows you to invoke the GitHub specific functionality.\nThe extremely term gh CLI manual can be found here.\nFor Windows users, you can pick up the latest Signed MSI executables from the release page.\nFor macOS, use homebrew:\nbrew install gh\n## ==&gt; Downloading https://formulae.brew.sh/api/formula.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/manifests/2.37.0\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/331c0b76fd34aa97342efa0e4e41373dbac71c28aeb49346b1284b3450f4105b--gh-2.37.0.bottle_manifest.json\n## ==&gt; Fetching gh\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/blobs/sha256:a8c21e08d77963c2d12102aefe38f8c010c573b771ccf729ea438c40dddb7f3a\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/d0e6a3f8f7a4b138b36484ec9ec8aff26b499381a0b4459f53efc0aefe001ee2--gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Pouring gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Caveats\n## Bash completion has been installed to:\n##   /opt/homebrew/etc/bash_completion.d\n## ==&gt; Summary\n## üç∫  /opt/homebrew/Cellar/gh/2.37.0: 191 files, 44.2MB\n## ==&gt; Running `brew cleanup gh`...\n## Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.\n## Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).\n\n5.3.1 GitHub CLI authentication\nIn order to make use of gh we need to go through another round of authentication setup. To do this, go to the terminal and run:\ngh auth login\n## ? What account do you want to log into? GitHub Enterprise Server\n## ? GHE hostname: github.sydney.edu.au\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\nFor additional information, see gh auth ‚Äìhelp.\nIn order to use gh with github.com directly you need to authenticate for that platform too. Repeat the above, but now the responses look like this:\ngh auth login\n## ? What account do you want to log into? GitHub.com\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\nYou are nearly set. You can verify that what you have configured worked via:\ngh auth status\n## github.sydney.edu.au\n##   ‚úì Logged in to github.sydney.edu.au as mjon7053 (keyring)\n##   ‚úì Git operations for github.sydney.edu.au configured to use https protocol.\n##   ‚úì Token: gho_************************************\n##   ‚úì Token scopes: gist, read:org, repo, workflow\n## \n## github.com\n##   ‚úì Logged in to github.com as maj-biostat (keyring)\n##   ‚úì Git operations for github.com configured to use https protocol.\n##   ‚úì Token: gho_************************************\n##   ‚úì Token scopes: gist, read:org, repo, workflow\nHowever, for gh to work with the desired host you need to set an environment variable to tell gh which platform to use. On macOS, you can set this up easily with the following entries in the .profile shell initialisation script (or .bash_profile for those inclined).\ngh-ent() {\n  export GH_HOST=github.sydney.edu.au\n}\n\ngh-std() {\n  export GH_HOST=github.com\n}\nOn Windows, I have no idea how you are supposed to do the above in an easy manner. You may just have to resort to running\nset GH_HOST=github.sydney.edu.au\nor\nset GH_HOST=github.com\neach time you want to switch.\nNow (on macOS) when you want to interrogate github.com repositories we can use the following commands.\n\n\n\n\n\n\nNote\n\n\n\nDo not worry about the meaning of the commands, this is just to establish that we have configured things correctly.\n\n\ngh-std\ngh repo list\n\n## Showing 30 of 185 repositories in @maj-biostat\n## \n## maj-biostat/misc-notes                         info for manjaro/arch linux setup                                public         1d\n## maj-biostat/wisca_2                            Revised approach to antibiogram                                  private        25d\n## maj-biostat/motc.run                                                                                            private        Sep 11, 2023\n## maj-biostat/motc.sim                           Simulation for motivate c trial                                  private        Sep 11, 2023\n## maj-biostat/motc.stan                          Stan models for motc                                             private        Sep  7, 2023\n## maj-biostat/quarto_demos_basic                 Demo using Quarto to render to word documents with custom te...  private        Aug 23, 2023\n## maj-biostat/BayesDRM                           Dose response models in stan                                     public         May 21, 2023\n## maj-biostat/motc.modproto                                                                                       public         May  1, 2023\nand for the USyd Enterprise GitHub Server, use:\ngh-ent\ngh repo list\n\nShowing 12 of 12 repositories in @mjon7053\n\nmjon7053/motc-mgt            Monitoring statistics for Motivate-C study                       private  1d\nmjon7053/fluvid.analyses     Analyses for fluvid coadministration study (COVID19 + FLU) vacc  private  17d\nmjon7053/motc.sap                                                                             public   Sep 14, 2023\nmjon7053/motc-sim-report     Motivate-C simulation report                                     private  Sep 12, 2023\nmjon7053/roadmap-notes       Notes relating to the ROADMAP project.                           private  Sep  2, 2023\nmjon7053/mjon7053.github.io                                                                   private  Aug 27, 2023"
  },
  {
    "objectID": "notebooks/part-02.html",
    "href": "notebooks/part-02.html",
    "title": "Part 2 - Fundamentals",
    "section": "",
    "text": "Now we will make a start with git. Initially we will focus on using git within the confines of your local machine. Yes, that‚Äôs right, for the moment, we won‚Äôt be using github at all. The point of this is to give you a chance to get to grips with the basic ideas. After the main concepts are bedded in, we will move to thinking about github, which is a whole new beast.\n\nAside.\ngit remote add origin https://github.com/career-karma-tutorials/ck-git gh repo create my-newrepo ‚Äìpublic ‚Äìsource=. ‚Äìremote=upstream ‚Äìpush\nThe first part of the one liner: gh repo create my-newrepo creates and names a repo in your account (note: ‚Äòmy-newrepo‚Äô should be replaced by the repo name of your choice) The -public flag makes sure the repo is public (swap this for -private if necessary) The -source=. flag specifies the source directory to be pushed Finally, the -remote=upstream flag specifies the remote repository to which the local repository is going to be compared with when pushing i.e the ‚Äòupstream‚Äô default."
  },
  {
    "objectID": "notebooks/git-repository.html#git-repositories",
    "href": "notebooks/git-repository.html#git-repositories",
    "title": "6¬† Repositories",
    "section": "6.1 Git repositories",
    "text": "6.1 Git repositories\nA repository is the most basic component of git. It is where you store your files and each files history. Through a variety of mechanisms, repositories can be public or private, can involve single people or multiple collaborators and can be stored locally (on your personal computer), in the cloud (in the cloud hosted by a service provider like github) or on a physical server (a basic file server will suffice in most cases).\nUsing git, you can create and configure repositories, add or remove files and review history of the files in the repository.\n\n6.1.1 Initialisation\nLet‚Äôs initialise a new repository. Run the following on your machine:\n\n# Change dir to the local workshop directory, \n# e.g. cd ~/Documents/get-going-with-git\nmkdir first-repo\n\ncd first-repo\n\ngit init\n## Initialized empty Git repository in /Users/mark/Documents/project/misc-stats/first-repo/.git/\ngit status\n## On branch main\n## \n## No commits yet\n## \n## nothing to commit (create/copy files and use \"git add\" to track)\n\nIf you received the output detailed above (or something very similar to it) then congratulations, you initialised a git repository.\nIf you have configured your file explorer to show hidden files, you will notice that the first-repo directory now contains a .git sub-directory. This directory contains the everything related to the repository. For examples, it contains all the version history and allows you to access files at any stage in their development. Generally, you will not touch this sub-directory directly.\n\n\n\n\n\n\nNote\n\n\n\nYou can also create a repository from a pre-existing directory that has already got an established file structure and files. The process is exactly the same, just change to the directory that you want to add to version control, and run git init.\nAdditionally, when you create a new project in Rstudio, you can select to initialise a new git repository. Underneath the covers, RStudio is simply invoking git init.\n\n\n\n\n6.1.2 Repository structures\nBefore we start adding files to the new repository, you need to be aware of a few concepts.\nThere are three main structures within the repository:\n\nWorking directory\nStaging area\nCommit history\n\n\n\n\nRepository structures\n\n\n\n6.1.2.1 Working directory\nIs the usual files and sub-directories within your project directory. You add, update, rename, delete files and direcotries in this area. When you first create a file or directory within the working directory, it is not yet under version control. Such files are referred to as untracked files.\n\n\n6.1.2.2 Staging area\nIs a special space to where you list the files that are added to be committed as a new version under version control.\n\n\n6.1.2.3 Commit history\nAfter staging files, they are committed to the repository. Once committed, files (and directories) are under version control and are referred to as tracked files. A commit is simply a version, but you could also think of it as a transaction with the repository. Changes to committed files are monitored and new updates to files can be committed to the repository as work on the project progresses. Every time you commit files, the commit history is saved."
  },
  {
    "objectID": "notebooks/git-commit.html#adding-files-to-projects",
    "href": "notebooks/git-commit.html#adding-files-to-projects",
    "title": "7¬† Stage and Commit",
    "section": "7.1 Adding files to projects",
    "text": "7.1 Adding files to projects\nLet‚Äôs start to introduce files for the project. Open a text editor, enter the following contents (or download the readme.md file from the applicable section under Chapter¬†1) and save the file as readme.md in the first-repo directory.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nDitto for the following and save the file as hello.R in the first-repo directory.\n\ncat(\"Enter a string please: \");\na &lt;- readLines(\"stdin\",n=1);\ncat(\"You entered\")\n\nstr(a);\ncat( \"\\n\" )\ncat(a, file = \"log.txt\")\n\nRun the R script from the terminal by entering this text:\n\nRscript hello.R\n\nNow from the terminal in the first-repo directory:\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  hello.R\n##  readme.md\n##  log.txt\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)\n\nWe see that there are three untracked files, two of which we will ultimately want to store in the git repository. In contrast to the newly initialised repository as shown in Section¬†6.1.2 we now have the following:\n\n\n\nAdd file to working directory\n\n\nThe above is idealised. You may encounter the situation where you have many files, a number of which you have no intention of tracking under version control. You can ignore these files by creating a .gitignore file, which tells git which files it should ignore.\nCreate a new text file with the following content and save the file as .gitignore. This is a special configuration filename that git recognises. The . at the front of gitignore is important.\nIf you missed the . or mistakenly added a .txt extension then the .gitignore functionality will not work.\n\n# .gitignore file contains files\n# that the repository will ignore\nlog.txt\n*.txt\n\nIf you list (ls - la) the files in the first-repo directory, you should see the following (or something very similar):\n\n192-168-1-100:first-repo mark$ ls -la\ntotal 32\ndrwxr-xr-x  7 mark  staff  224  7 Nov 10:15 .\ndrwxr-xr-x  8 mark  staff  256  7 Nov 10:12 ..\ndrwxr-xr-x  9 mark  staff  288  7 Nov 10:15 .git\n-rw-r--r--@ 1 mark  staff   81  7 Nov 10:15 .gitignore\n-rw-r--r--@ 1 mark  staff  126  7 Nov 10:13 hello.R\n-rw-r--r--  1 mark  staff    4  7 Nov 10:14 log.txt\n-rw-r--r--@ 1 mark  staff   59  7 Nov 10:13 readme.md\n\nRun git status again and note that the log.txt file no longer registers with git.\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  .gitignore\n##  hello.R\n##  readme.md\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)"
  },
  {
    "objectID": "notebooks/git-commit.html#commit-process",
    "href": "notebooks/git-commit.html#commit-process",
    "title": "7¬† Stage and Commit",
    "section": "7.2 Commit process",
    "text": "7.2 Commit process\nNow we want to add the new file to the repository. The steps are\n\nAdd the file (or files) that we want to include in the repository to the staging area\nCommit the staged files\n\n\n7.2.1 Staging\nTo add the files into the staging area run the commands:\n\ngit add hello.R readme.md .gitignore\n\nNote that the .gitignore file was added as well as the hello.R and readme.md files. Now run\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Changes to be committed:\n##   (use \"git rm --cached &lt;file&gt;...\" to unstage)\n##  new file:   .gitignore\n##  new file:   hello.R\n##  new file:   readme.md\n\nWe can see that no commits have occurred but that we have staged the files that we want to add to the repository.\nWhat happens if we accidentally add a file that we did not want to add (the -f says we want to add a file that is included in the .gitignore list)?\n\ngit add -f log.txt\n\nif you run git status you will see that log.txt is also staged. To remove log.txt from the staged area:\n\ngit reset log.txt\n\nNow the picture looks like this.\n\n\n\nAdd file to staging area\n\n\n\n\n7.2.2 Commit\nTo commit the files that have been staged:\n\ngit commit -m \"First commit\" \n## [main (root-commit) 728d107] First commit\n##  3 files changed, 15 insertions(+)\n##  create mode 100644 .gitignore\n##  create mode 100644 hello.R\n##  create mode 100644 readme.md\n\nthe -m flag is necessary. When you make a commit, you need to provide a message that describes the nature of the changes.\nWhat is the weird stuff that is output prior to the commit message ([main (root-commit) 728d107]) in the commit history? It is a unique hash code that identifies this specific version of the project. Note, you will have a different hash code (and that is fine).\nWhen we run git status we see that the repository is up to date with the working area files. We also see that the files have been removed from the staging area.\n\ngit status\n## On branch main\n## nothing to commit, working tree clean\n\n\n\n\nCommit files to history"
  },
  {
    "objectID": "notebooks/git-commit.html#exercises",
    "href": "notebooks/git-commit.html#exercises",
    "title": "7¬† Stage and Commit",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\nExercise 7.1 Create a new R script in the working directory, it can contain anything you like. If you are lost, just use:\n\nlibrary(survival)\nprint(\"My script\")\n\nand save it as myscript.R.\n\n\nExercise 7.2 Add the new script to the staging area by following Section¬†7.2.1 ensuring that you review the status.\n\n\nExercise 7.3 Commit the staged files to the repository by following Section¬†7.2.2 making sure that you record a message for your commit.\n\n\nExercise 7.4 Edit the readme.md (use notepad or rstudio) file adding a new line with some arbitrary text. Stage the file and commit."
  },
  {
    "objectID": "notebooks/git-commit.html#tracking-commit-history",
    "href": "notebooks/git-commit.html#tracking-commit-history",
    "title": "7¬† Stage and Commit",
    "section": "7.4 Tracking commit history",
    "text": "7.4 Tracking commit history\nOne of the most notable features of revision control is that you can review your project file history. The simplest way to do this is with git log which will report all of the commits in reverse chronological order. You can see\n\nwho made the commits\nwhen they were made and why (the commit messages)\nthe hash code associated with project version at each commit\n\nnote that the full hash is reported whereas previous a truncated version is shown\n\n\nThe commit followed by (HEAD -&gt; main) shows what part of the history our working directory currently reflects.\nHere is an example (your repository will look different but that is ok)\n\ngit log\n\n## commit 327170a6bc4d39463c4cfbc0f257420496642cb5 (HEAD -&gt; main)\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:25:23 2023 +0800\n## \n##     Minor edit\n## \n## commit b078716e80498c2fa7abfb8ae27b204b2dc603d8\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:24:58 2023 +0800\n## \n##     New file\n## \n## commit 0cd2d52e989059a61315525a3488e06d22cd04a5\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:23:23 2023 +0800\n## \n##     First commit\n\nYou can format the logs in a variety of ways. For a more condensed view you can use the --oneline flag:\n\ngit log --oneline\n## 327170a (HEAD -&gt; main) Minor edit\n## b078716 New file\n## 0cd2d52 First commit\n\nIf you want the commit history for the last n commits, or between specific dates, or by author or even via searching for a specific string in the message you can run the following\n\ngit log -n 2\ngit log --after=\"2013-11-01\" --before=\"2023-10-15\"\ngit log --author=\"Mark\\|Fred\"\ngit log --grep=\"first\" -i\n\nTry them.\nThe first restricts to the last two commits, the second returns commits between mid Oct and the start of Nov, the second returns commits made by Mark or Fred and the third returns any commits where the word first was included in the message text (ignoring case).\nThe log command is powerful and it lets you see who updated the files, when they made the update and why they did it. Obviously, this has less utility when you are working on a repository in isolation but it still does have value (especially to your future self). For example, you might simply want to review when specific changes were made to the files or you might want to pick up some update that has been removed from the code and reintroduce it.\nWhen you are working on a repository in collaboration (see later) the value of the logs increases many fold as a way to be able to understand the evolution of the project and to work out who you need to contact if you think a problem has been introduced.\nTo establish what files were included in any given commit, you can use git show:\n\ngit show --name-only 0cd2d52\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Tue Nov 7 10:23:23 2023 +0800\n## \n##     First commit\n## \n## .gitignore\n## hello.R\n## readme.md"
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "href": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "title": "8¬† Reviewing differences",
    "section": "8.1 Comparisons with the working directory",
    "text": "8.1 Comparisons with the working directory\nGit allows you to compare different versions of files that exist in the repository. In its vanilla form, the difference functionality compares the differences in a file (or files) in the working directory to the repository version.\nUpdate the contents of the hello.R script to match what follows.\n\ncat(paste0(\"What is your name?\\n\"));\nnme &lt;- readLines(\"stdin\",n=1);\ncat(paste0(\"Hi \",nme, \" enter a string please: \\n\"));\na &lt;- readLines(\"stdin\",n=1);\ncat(\"You entered the following string: \")\ncat(paste0(a, \"\\n\"));\ncat(a, file = \"log.txt\")\n\nSimilarly, edit the readme.md file as below.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nA new line for testing.\n\nContains standalone R scripts.\n\nRunning git status you will see that the working directory uncommitted changes\n\ngit status\n## On branch main\n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   hello.R\n##  modified:   readme.md\n## \n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf we want to know what changes were made, we can run git diff but let‚Äôs looks at the differences on a file by file basis, comparing the old with the new.\n\ngit diff readme.md\n## diff --git a/readme.md b/readme.md\n## index 7501d7c..6929e2c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,5 +4,7 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## +Contains standalone R scripts.\n## +\n\nYou interpret the above as follows.\n\nAnything prefixed with - belongs to the old file and anything prefixed with + belongs to the new.\nThe section labelled with @@ gives you some context as to where the change has happened. In this case we can see that the text A minor revision has been removed and replaced with the text The main script implements a loop to capture input from a user.\n\nNow compare the working version of hello.R with the repository version, but this time look at the word by word differences:\n\ngit diff --word-diff hello.R\n## diff --git a/hello.R b/hello.R\n## index 0c6d38c..5f09b06 100644\n## --- a/hello.R\n## +++ b/hello.R\n## @@ -1,7 +1,9 @@\n## [-cat(\"Enter-]{+cat(paste0(\"What is your name?\\n\"));+}\n## {+nme &lt;- readLines(\"stdin\",n=1);+}\n## {+cat(paste0(\"Hi \",nme, \" enter+} a string please: [-\");-]{+\\n\"));+}\n## a &lt;- readLines(\"stdin\",n=1);\n## cat(\"You [-entered\")-]\n## \n## [-str(a);-]\n## [-cat( \"\\n\" )-]{+entered the following string: \")+}\n## {+cat(paste0(a, \"\\n\"));+}\n## cat(a, file = \"log.txt\")\n\nThe diffs can take a bit of getting used to and some alternative tools are available that we will put to use in due course. For now, we will just deal with the commandline output.\nOnce satisfied that the changes are benign, stage and commit the edits in the usual way:\n\ngit add hello.R readme.md\ngit commit -m \"Revised approach in capturing user input\""
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "href": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "title": "8¬† Reviewing differences",
    "section": "8.2 Comparisons with staged files",
    "text": "8.2 Comparisons with staged files\nIf you want to restrict your attention to the differences that will be made to a repository due to committing staged files, you can use git diff --cached."
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "href": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "title": "8¬† Reviewing differences",
    "section": "8.3 Comparisons across commit versions",
    "text": "8.3 Comparisons across commit versions\nOnce working directory changes have been committed to the repository it is still possible to review the differences between commit.\nThe most common difference that is of interest is that between the last two commits. To achieve this run\n\ngit diff HEAD 327170a\n\nTo inspect differences between any commits, you simply supply the commit hashes that you want to compare:\n\ngit diff b078716 0cd2d52\n## diff --git a/myscript.R b/myscript.R\n## deleted file mode 100644\n## index a12204c..0000000\n## --- a/myscript.R\n## +++ /dev/null\n## @@ -1,3 +0,0 @@\n## -library(survival)\n## -print(\"My script\")\n## -\n\nIf you want to restrict attention to a particular file, just add the filename that you want to compare to the end of the command\n\ngit diff HEAD 327170a readme.md\n## diff --git a/readme.md b/readme.md\n## index 6929e2c..7501d7c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,7 +4,5 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## -Contains standalone R scripts.\n## -"
  },
  {
    "objectID": "notebooks/git-branch.html#what-is-a-branch",
    "href": "notebooks/git-branch.html#what-is-a-branch",
    "title": "9¬† Branches",
    "section": "9.1 What is a branch?",
    "text": "9.1 What is a branch?\n\n\n\n\n\n\nWarning\n\n\n\nWe are going to step it up a notch. The topic of branching can be challenging for beginners. Practice and repitition is key to understanding. Try not to panic. At a basic level, it is actually straight forward once you get familiar with the processes.\n\n\nWhen you run git status you saw the text - On branch main as part of the output. Similarly, when you ran git log the last commit reported is suffixed with (HEAD -&gt; main). Both of these were a reference to the version on the branch that is currently linked to the working directory.\nBranching is simply a mechanism that allows you to diverge from the main line of development and continue to do work without messing with that main line. They allow multiple pieces of work to be progressed independently within the same project.\nFor example, initially there is a singular progression of the project, but at some point you will want to create a release for a software product, or a piece of documentation or an analysis. Later you may want to revise the release due to changes in project direction, new data, bugs etc. You use branches to facilitate this process in a logical and coherent way.\nIn the examples encountered so far, the branching we have encountered is just a stem (specifically, the main branch). Here is a common type of representation of the kind of branch that we have dealth with so far. The circles represent each commit, which would refer to changes in one or more files. The repository has gone through a series of commits (1, 2, 3, 4 etc.) and the working directory is currently looking at the repository version 4.\n\n\n\nBranch more like a stem\n\n\nThe arrow pointing at 4 is the current HEAD of the repository. HEAD is a special concept in git. It answers the question ‚ÄúWhat am I currently looking at?‚Äù"
  },
  {
    "objectID": "notebooks/git-branch.html#time-travel",
    "href": "notebooks/git-branch.html#time-travel",
    "title": "9¬† Branches",
    "section": "9.2 Time travel",
    "text": "9.2 Time travel\nThe concepts associated with branching are easiest understood by demonstration and experimentation.\nWhen you make a new commit to git, the branch reference is updated to point to the new commit. When you move to a new branch, the HEAD reference is updated to point to the branch that you switched to.\nGo to the Chapter¬†1 resources page and save the branching.R file to your first-repo directory.\nThe file contains the following:\n\n\nCode\n# R script to demo branching\nsuppressPackageStartupMessages(library(data.table))\nsuppressPackageStartupMessages(library(survival))\nsuppressPackageStartupMessages(library(rtables))\nsuppressPackageStartupMessages(library(ggplot2))\n\nmessage(\"-------------------------------\")\nmessage(\"NOW WE WILL MOVE ONTO BRUNCHING\\n\")\nmessage(\"-------------------------------\")\n\n\n# Data generation  ------------------\nset.seed(1)\n\nN &lt;- 4000\nd &lt;- data.table(\n  id = 1:N,\n  u = rbinom(N, 1, 0.5)\n)\n\nd[u == 0, x := rbinom(.N, 1, 0.2)]\nd[u == 1, x := rbinom(.N, 1, 0.8)]\n\nb0 &lt;- 3\nb1 &lt;- 1\nb2 &lt;- -2\nb3 &lt;- -1\ne &lt;- 1\nw_cens &lt;- 4\n\n# Continuous outcome\nd[, mu := b0 + b1 * x + b2 * u + b3 * x * u]\nd[, y := rnorm(.N, mu, 1)]\n\n# Binary outcome\nd[x == 1, z := rbinom(.N, 1, 0.7)]\nd[x == 0, z := rbinom(.N, 1, 0.3)]\n\n# Survival outcome\n# Median tte -log(0.5)/0.6 vs -log(0.5)\nd[x == 1, w := rexp(.N, 0.6)]\nd[x == 0, w := rexp(.N, 1.0)]\nd[, evt := as.integer(w &lt; w_cens)]\nd[evt == 0, w := w_cens]\n\n# Labels\nd[x == 0, arm := \"FBI\"]\nd[x == 1, arm := \"ACTIVE\"]\n\nd[u == 0, age := \"&lt; 50 years\"]\nd[u == 1, age := \"&gt;= 50 years\"]\n\n# Descriptive summary -------\n\nmessage(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n\nlyt &lt;- basic_table() %&gt;%\n  split_cols_by(\"arm\") %&gt;%\n  summarize_row_groups() %&gt;%\n  analyze(\"y\", mean, format = \"xx.x\")\n\nbuild_table(lyt, d)\n\n# Analyses --------\n\nmessage(\"\\n\\nANALYSIS OF CONTINOUS OUTCOME (UNSTRATIFIED):\\n\")\n\nlm1 &lt;- lm(y ~ x, data = d)\nsummary(lm1)\n\n\nRun the script:\n\nRscript branching.R\n\nImagine this was the first analysis for a project and will be sent to the clients. The completed work represents a milestone for the project so we stage and commit the file and then create a tag for it.\n\ngit tag -a v1.0 -m \"Analysis 1\"\n\nWe continue with the work for the next deliverable completing a secondary analysis on the binary outcome z. Add the following code to the end of the branching.R script, re-run with Rscript branching.R and then commit the file to the repository.\n\nmessage(\"\\n\\nANALYSIS OF BINARY OUTCOME (UNSTRATIFIED):\\n\")\n\nlm2 &lt;- glm(z ~ x, data = d, family = binomial)\nsummary(lm2)\n\npr &lt;- predict(lm2, newdata = data.table(x = 0:1), type = \"response\", se = T)\nd_fit &lt;- data.table(\n  arm = c(\"PBO\", \"ACTIVE\"),\n  x = 0:1,\n  pr_z = pr$fit,\n  pr_z_lb = pr$fit - 2 * pr$se.fit,\n  pr_z_ub = pr$fit + 2 * pr$se.fit\n)\n\nWe are not finished with our second deliverable, but at this point we realise that the initial analysis that was sent to the client was incorrect. As you may have spotted, we should have run a stratified analysis due to the presence of a confounder. We urgently need to re-issue the corrected analysis to the client. Bummer.\nIn contrast to the minor change above, in real life we might be much further along with this next deliverable, which may be vastly more complex than what I have illustrated above. For example, we may have introduced new files, restructured the original analysis, added functionality etc.\nWhile we could go through the process of winding back all the changes, with revision control we do not have to because we can rewind to any point.\nNext we go over the processes involved.\n\n9.2.1 Commit\nFirst thing to do is to check that your code is running ok and then commit any files that have not yet been committed to the repository. Not doing so will cause you some major headaches, so best advice is to not forget to do this.\n\ngit status\ngit add braching.R\ngit commit -m \"Commit of files part way through development\"\n\n\n\n9.2.2 Rewind\nNow we want to rewind our repository back to the time at which the deliverable was made. We can do this by using git log to find the commit hash or we can just use the tag that we set for the release. Using the tag is more convenient so let‚Äôs do that.\n\ngit log --oneline\ngit checkout v1.0\n## Note: switching to 'v1.0'.\n## \n## You are in 'detached HEAD' state. You can look around, make experimental\n## changes and commit them, and you can discard any commits you make in this\n## state without impacting any branches by switching back to a branch.\n## \n## If you want to create a new branch to retain commits you create, you may\n## do so (now or later) by using -c with the switch command. Example:\n## \n##   git switch -c &lt;new-branch-name&gt;\n## \n## Or undo this operation with:\n## \n##   git switch -\n## \n## Turn off this advice by setting config variable advice.detachedHead to false\n## \n## HEAD is now at a2cc6f7 Comments from code review\n\nIn terms of the schematic of the repository, the environment now looks like this.\n\n\n\nRewind to earlier deliverable\n\n\nWe have move the HEAD such that our working versions now point to the files that were originally delivered to the client.\n\n\n\n\n\n\nNote\n\n\n\nDon‚Äôt panic overly about the warning about being in the detached HEAD state.\n\n\nIf you look at branching.R you will see that the starts of the secondary analysis has disappeared.\n\n\n9.2.3 Fix issue\nIn order to fix the analysis we need to introduce the confounder as a covariate in the linear model. Introduce the following fixes. First to the descriptive summary:\n\nmessage(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n\nlyt &lt;- basic_table() %&gt;%\n  split_cols_by(\"arm\") %&gt;%\n  split_rows_by(\"age\") %&gt;%\n  summarize_row_groups() %&gt;%\n  analyze(\"y\", mean, format = \"xx.x\")\n\nbuild_table(lyt, d)\n\nand then to the analysis make these corrections and finally re-run the script to confirm that it produces what we expect.\n\nlm1 &lt;- lm(y ~ x * u, data = d)\nsummary(lm1)\n\nStage and then commit these changes. We can get some insight into the state of the tree now. Below I have added one more commit so that you can get a sense of how things are progressing.\n\ngit log --oneline --decorate --graph --all\n## * 7ab12b3 (HEAD) Code review correction\n## * 4cca810 Added emergency fix\n## | * c82a48d (main) Started on secondary analyses\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\nThe equivalent illustration would look something like this:\n\n\n\nAdd a fix\n\n\n\n\n9.2.4 Make permanent\nNow that we have fixed the code, we want to make the change permanent. That is, we want to formally tell git that our alternative history should be maintained. The way to do that is to create a new branch out of the recent changes (which already look like a branch).\n\ngit branch fix-01\n# Switch to new branch\ngit checkout fix-01\n\nWhen we look at the tree we see both HEAD and the branch (note the first line text which says HEAD, fix-01).\n\ngit log --oneline --decorate --graph --all\n## * 7ab12b3 (HEAD, fix-01) Code review correction\n## * 4cca810 Added emergency fix\n## | * c82a48d (main) Started on secondary analyses\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\nAnd now the picture is\n\n\n\nLooking at the HEAD of our new branch\n\n\nIf this is the version that we re-issue to the client, we might as well tag it.\n\ngit tag -a v1.1 -m \"Analysis 1 (re-issue)\"\n\n\n\n9.2.5 Switching back to the secondary\nSwitching back to our partially complete secondary analysis is as simple as.\n\ngit checkout main\n\nIf you look at the branching.R script you will be able to see the secondary analysis we started some time ago. However, if you look closely you will see that the changes we just made in the fix-01 branch have not yet been propagated to the main branch. It is important that we pick up this fix.\nThis process is known as merging and it will be tackled later."
  },
  {
    "objectID": "notebooks/git-merge.html#recap",
    "href": "notebooks/git-merge.html#recap",
    "title": "10¬† Merge",
    "section": "10.1 Recap",
    "text": "10.1 Recap\nFrom the previous branching example -\n\nWe delivered stage one of an analysis to the client\nWe started on the secondary analyses\nBefore the secondary analysis was complete, we realised there was an error in the original analysis that needed an emergency fix\nWe rewound to an earlier state in the repository and then fixed the error and checked in our work\nWe made the work permanent by creating a new branch and then checking out that branch\nWe tagged the fix and the re-issued the analysis to the client\nWe jumped back to our secondary analysis by checking out the main branch\n\nOk, so now we have a fix to the error in the original analysis in one branch fix-01 and a partially completed secondary analysis on the main branch. We want to bring the changes from the fix into our present work."
  },
  {
    "objectID": "notebooks/git-merge.html#merge-processes",
    "href": "notebooks/git-merge.html#merge-processes",
    "title": "10¬† Merge",
    "section": "10.2 Merge processes",
    "text": "10.2 Merge processes\nMerging is usually a fairly automated process. Run the following.\n\ngit checkout main\ngit merge fix-01\n\nYou may be prompted to enter a commit message (alternatively just provide the -m flag).\n\nMerge branch 'fix-01'\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n\nand then the following output.\n\n## Auto-merging branching.R\n## Merge made by the 'ort' strategy.\n##  branching.R | 3 ++-\n##  1 file changed, 2 insertions(+), 1 deletion(-)\n\nIf you look at the difference between the HEAD (the HEAD~1 notation means compare with the previous commit, HEAD~2 means compare with 2 commits prior and so on) and the commit associated with the merge you will see\n\ngit diff HEAD~1\n## diff --git a/branching.R b/branching.R\n## index b60c9f0..8f1c1b3 100644\n## --- a/branching.R\n## +++ b/branching.R\n## @@ -45,6 +45,7 @@ message(\"\\nDESCRIPTIVE SUMMARY:\\n\")\n## \n##  lyt &lt;- basic_table() %&gt;%\n##    split_cols_by(\"arm\") %&gt;%\n## +  split_rows_by(\"age\") %&gt;%\n##    summarize_row_groups() %&gt;%\n##    analyze(\"y\", mean, format = \"xx.x\")\n## \n## @@ -54,7 +55,7 @@ build_table(lyt, d)\n## \n##  message(\"\\n\\nANALYSIS OF CONTINOUS OUTCOME (UNSTRATIFIED):\\n\")\n## \n## -lm1 &lt;- lm(y ~ x, data = d)\n## +lm1 &lt;- lm(y ~ x * u, data = d)\n##  summary(lm1)\n## \n##  message(\"\\n\\nANALYSIS OF BINARY OUTCOME (UNSTRATIFIED):\\n\")\n\nWe now have the changes from the emergency fix in the main branch and we can continue with the secondary analysis.\nSometimes merging doesn‚Äôt work quite so smoothly and we need to iron out conflicts."
  },
  {
    "objectID": "notebooks/git-merge.html#exercises",
    "href": "notebooks/git-merge.html#exercises",
    "title": "10¬† Merge",
    "section": "10.3 Exercises",
    "text": "10.3 Exercises\n\nExercise 10.1 Complete the analysis by adding the following code to generate a figure from the fitted model.\n\np1 &lt;- ggplot(d_fit, aes(x = arm, y  = pr_z)) +\n  geom_point() +\n  geom_linerange(aes(ymin = pr_z_lb, ymax = pr_z_ub)) +\n  scale_x_discrete(\"\") +\n  scale_y_continuous(\"Probability of response\")\n\nggsave(\"fig-sec.png\", p1, width = 10, height = 10, units = \"cm\")\n\nHere is what you need to do:\n\nRun the updated script Rscript branching.R to make sure it works.\nEdit the .gitignore file so that the figure does not get committed to the repository.\nStage and commit the files and then review the commit history.\nCreate a v2.0 tag with an meaningful message.\n\n\n\nExercise 10.2 Usually it makes sense to create a new branch for each piece of development we undertake. This ensures that the main branch continues to reflect a working version at all times. Create a new branch from the current state and call it analysis-03. Run the following code:\n\ngit branch analysis-03\ngit checkout analysis-03\ngit status\n\nAdd the analysis code into branching.R\n\nmessage(\"\\n\\nANALYSIS OF SURVIVAL OUTCOME (UNSTRATIFIED):\\n\")\nlm3 &lt;- coxph(Surv(w, evt) ~ x, data = d)\nsummary(lm3)\n\nRun the script to make sure it works then stage and commit along with an updated .gitignore files that excludes all png files.\nCheckout main:\n\ngit checkout main\n\nAdd the following change to the branching.R code (just adding a new theme to the ggplot figure)\n\np1 &lt;- ggplot(d_fit, aes(x = arm, y  = pr_z)) +\n  geom_point() +\n  geom_linerange(aes(ymin = pr_z_lb, ymax = pr_z_ub)) +\n  scale_x_discrete(\"\") +\n  scale_y_continuous(\"Probability of response\") +\n  theme_bw()\n\nRun the script, then stage and commit.\nCheckout analysis-03 branch:\n\ngit checkout analysis-03\n\nAdd the following code:\n\npng(\"fig-surv.png\")\nplot(survfit(Surv(w, evt) ~ x, data = d), lty = 1:2)\ndev.off()\n\nRun the script to make sure it works then stage and commit. Treat this as the release by tagging it as v3.0. Checkout the main branch and merge the analysis into main.\n\ngit checkout main\ngit merge analysis-03\n\nReview the commit history:\n\ngit log --oneline --decorate --graph --all\n## *   2829471 (HEAD -&gt; main) Merge branch 'analysis-03'\n## |\\\n## | * be09457 (tag: v3.0, analysis-03) Finished surv\n## | * 7a5e7b9 Surv analysis\n## * | 53115b6 minor\n## |/\n## * 1a9dfeb (tag: v2.0) Edits from code review\n## * d1586df Completion of secondary analysis\n## *   bf34b9c Merge from fix-01\n## |\\\n## | * b8de16c (tag: v1.1, fix-01) Edits from code review\n## | * 12561d9 Emergency fix\n## * | d88f9e5 WIP\n## |/\n## * a2cc6f7 (tag: v1.0) Comments from code review\n## * fa24778 branching.R\n## * 3bdac46 Revised approach to capturing input\n## * 327170a Minor edit\n## * b078716 New file\n## * 0cd2d52 First commit\n\n\nAt this point, you have the fundamentals. However, there are things that are going to catch you out. For example, in the above work, we used three-way merges. These are convenient but can also get messy when your branching structure gets complex. In most of our daily work merges will probably suffice, but know that there is another way. The other way is rebasing, but we will not deal with it here."
  },
  {
    "objectID": "notebooks/part-03.html",
    "href": "notebooks/part-03.html",
    "title": "Part 3 - Collaboration",
    "section": "",
    "text": "Remotes\nHosting git"
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#no-github",
    "href": "notebooks/git-collab-fileserver.html#no-github",
    "title": "11¬† Collaboration 1",
    "section": "11.1 No github?",
    "text": "11.1 No github?\nGitHub is a hosting service for git repositories. It also extends some of the git functionality. They have captured the market, mainly because people are stupid.\nBefore 2008, GitHub did not exist, and it wasn‚Äôt a catastrophe. What did we do? Git has the functionality built into it to allow collaboration via hosting git repositories directly on fileservers. This is a reasonable solution for small teams with access to a common network, but it has its limitations. Nevertheless, most bluechip organisations used this approach during the 2000‚Äôs.\nRepositories that are retained outside of your local machine are referred to as remotes. It doesn‚Äôt matter whether they are hosted on LIQUID, or a random file server or GitHub or BitBucket or Timbuktu. They are still known as remotes.\nRemotes allow you to work on a repository collaboratively with your colleagues. This has been standard practice in software development since circa 1760.\nWe will talk about hosting remotes on fileservers here and then move on to GitHub next."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#so-remote",
    "href": "notebooks/git-collab-fileserver.html#so-remote",
    "title": "11¬† Collaboration 1",
    "section": "11.2 So remote",
    "text": "11.2 So remote\nWhat remote (or remotes) are associated with the example repository that we have been working on? Let‚Äôs look.\n\ngit remote -v\n\nNo remotes.\nIf at any time you want to review the remotes associated with your repository (you can have more than one remote) then invoke the command that we just used."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#initialising-remotes",
    "href": "notebooks/git-collab-fileserver.html#initialising-remotes",
    "title": "11¬† Collaboration 1",
    "section": "11.3 Initialising remotes",
    "text": "11.3 Initialising remotes\nLet‚Äôs set up a remote on OneDrive. OneDrive is a cloud file-server, but technically we could replace OneDrive with any file-server. For example, we used to have the LIQUID drive at TKI mounted as a network drive and we could use that.\nAnyway, just follow along.\n\ngit clone --bare first-repo /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\n\nWhy USyd (or Microsoft) uses such ludicrous names for their software is beyond me.\nThe above takes the repository that we have been working on and moves the git database to OneDrive. If we look at OneDrive then we see:\n\npwd\n## /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\nls -lrta\n## total 48\n## drwx------@  20 mark  staff   640  8 Nov 08:36 ..\n## -rw-r--r--    1 mark  staff    73  8 Nov 08:36 description\n## -rw-r--r--    1 mark  staff   188  8 Nov 08:36 config\n## -rw-r--r--    1 mark  staff   618  8 Nov 08:36 packed-refs\n## -rw-r--r--    1 mark  staff    21  8 Nov 08:36 HEAD\n## drwxr-xr-x@  11 mark  staff   352  8 Nov 08:36 .\n## drwxr-xr-x    3 mark  staff    96  8 Nov 08:36 info\n## drwxr-xr-x   16 mark  staff   512  8 Nov 08:36 hooks\n## drwxr-xr-x  105 mark  staff  3360  8 Nov 08:36 objects\n## drwxr-xr-x    5 mark  staff   160  8 Nov 08:36 refs\n## -rw-r--r--@   1 mark  staff  6148  8 Nov 08:36 .DS_Store\n\nThe first thing to note is that there is no working directory.\nNow let‚Äôs imagine that I Sylvie has just joined the team as naive Bayesian statistician. Sylvie needs to start work on the first-repo project. First, we need to get the repository onto her local machine.\nThe process is as follows.\n\nGo to you Documents folder (or wherever you intend to store your projects)\nClone the remote\n\nObviously, I am working off a single laptop clone the repo to some alternative name. I will refer to this location as Sylvie‚Äôs repo vs Mark‚Äôs repo which is the one that I have been referencing when demonstrating examples.\nIn contrast to the bare repository remote, we (Sylvie) now has the example files that we have been developing to date.\n\n\n\n\n\n\nNote\n\n\n\nNote that I called the repo sylvie-first-repo. We can call the local version of the repo whatever we want.\n\n\n\ncd /Users/mark/Documents/\ngit clone /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git sylvie-first-repo\nls -lrta\n## total 40\n## drwxr-xr-x   3 mark  staff    96  8 Nov 11:07 ..\n## -rw-r--r--   1 mark  staff   100  8 Nov 11:07 .gitignore\n## -rw-r--r--   1 mark  staff  2274  8 Nov 11:07 branching.R\n## -rw-r--r--   1 mark  staff   242  8 Nov 11:07 hello.R\n## -rw-r--r--   1 mark  staff    38  8 Nov 11:07 myscript.R\n## drwxr-xr-x   8 mark  staff   256  8 Nov 11:07 .\n## -rw-r--r--   1 mark  staff   138  8 Nov 11:07 readme.md\n## drwxr-xr-x  12 mark  staff   384  8 Nov 11:07 .git\n\nLook at the details of the remote associated with Sylvie‚Äôs repo:\n\ncd /Users/mark/Documents/sylvie-first-repo/\ngit remote -v\norigin  /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\norigin  /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nThe picture now looks like this\n\n\n\nClone repository\n\n\nOver on the left we have the remote git database. On the right we have Mark who created the remote from his local repository and Sylvie who cloned the remote repository to her local machine."
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#keeping-remotes-up-to-date",
    "href": "notebooks/git-collab-fileserver.html#keeping-remotes-up-to-date",
    "title": "11¬† Collaboration 1",
    "section": "11.4 Keeping remotes up to date",
    "text": "11.4 Keeping remotes up to date\nYou can think of a remote as the hub around which collaboration revolves. As a project progresses, the local files are updated and we need to get these files into the remote so that our colleagues can keep their work in sync. However, someone else may send their files to the remote prior to you completing your work.\nThis would mean that the state of the remote is ahead of your local repository.\ngit (and GitHub) will not allow you to send your updates to the repository unless you are sync‚Äôd. In other words, you have to be up to date in order to send your changes to the remote.\nTo be able to push your work up to the remote, the steps are:\n\nensure that all your changes are committed to the local repository\nrun git fetch to establish whether you are up to date with the remote\nif necessary, merge any changes into your local repository to get up to date\nensure that all your changes are committed to the local repository\npush you modifications up to the remote\n\nIt sounds a bit involved, but in practice it is simple.\n\n11.4.1 Fetch and push (simple case)\nFirst Silvie ensures that all her local changes are committed to the repository. It looks like Silvie made a change to the readme.md when we were not looking.\n\ncd sylvie-first-repo\ngit status\n## On branch main\n## Your branch is up to date with 'origin/main'.\n## \n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   readme.md\n## \n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\ngit add readme.md; git commit -m \"Minor change for testing fetch\"\n\nNo changes have been made to the remote by anyone else so when we run git fetch there is no response. Therefore we can go and push the changes.\n\ngit push\n## Enumerating objects: 5, done.\n## Counting objects: 100% (5/5), done.\n## Delta compression using up to 8 threads\n## Compressing objects: 100% (3/3), done.\n## Writing objects: 100% (3/3), 342 bytes | 342.00 KiB/s, done.\n## Total 3 (delta 2), reused 0 (delta 0), pack-reused 0\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##    7eee4b5..49225cc  main -&gt; main\n\nLooking at the logs we see the following\n\ngit log --oneline\n## 3a3dd8d (HEAD -&gt; main, origin/main, origin/HEAD) Testing Sylvie\n## 2829471 Merge branch 'analysis-03'\n## be09457 (tag: v3.0, origin/analysis-03) Finished surv\n## 53115b6 minor\n## 7a5e7b9 Surv analysis\n## 1a9dfeb (tag: v2.0) Edits from code review\n## d1586df Completion of secondary analysis\n## bf34b9c Merge from fix-01\n## b8de16c (tag: v1.1, origin/fix-01) Edits from code review\n## 12561d9 Emergency fix\n## d88f9e5 WIP\n## a2cc6f7 (tag: v1.0) Comments from code review\n## fa24778 branching.R\n## 3bdac46 Revised approach to capturing input\n## 327170a Minor edit\n## b078716 New file\n## 0cd2d52 First commit\n\n\n\n11.4.2 Fetch and push (merge required)\nIn the interim Mark has been working on the first-repo and will want to get these changes into the remote. However, Mark hasn‚Äôt yet linked his local repository with the remote.\n\ngit remote -v\n## nothing\n\nIt is simple to fix this with git remote add which, predictably tells git to configure a link between a local and remote version of the repository. The use of the word origin is just convention and it is a shortcut for the full directory path (or URL) for the remote. You can call the remote anything you want but most people stick with the convention of origin, which is a bit like the convention of using main for the main branch.\n\ngit remote add origin /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\ngit remote -v\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nNext, we need to tell the local repository to reference this remote.\n\ngit remote add origin /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney\\(Staff\\)/first-repo.git\ngit remote -v\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (fetch)\n## origin   /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git (push)\n\nWe see that the remote has been added for both push and fetch. Before we use these, we need to make an existing local branch track a specific remote branch which is achieved with\n\ngit fetch  # pulls down information on the branches in the remote\ngit branch --set-upstream-to=origin/main main # links a local with remote branch\n\nChecking the status we see that the change that Sylvie pushed has left us out of sync.\n\ngit status\n## On branch main\n## Your branch and 'origin/main' have diverged,\n## and have 1 and 1 different commits each, respectively.\n##   (use \"git pull\" if you want to integrate the remote branch with yours)\n## \n## nothing to commit, working tree clean\n\nIf I try to push my change anyway, git barfs:\n\ngit push\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##  ! [rejected]        main -&gt; main (non-fast-forward)\n## error: failed to push some refs to '/Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git'\n## hint: Updates were rejected because the tip of your current branch is behind\n## hint: its remote counterpart. If you want to integrate the remote changes,\n## hint: use 'git pull' before pushing again.\n## hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\nThis is what I was referring to earlier. Git will not allow you to screw up the remote without some strenous effort on your part. It would be nice if git had told us what was different, but it forces us to do this via the following:\n\ngit fetch # this was done previously, but just to be clear that you need to do a fetch first\ngit diff main origin/main\n## diff --git a/readme.md b/readme.md\n## index 0165627..797358c 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,7 +4,9 @@ A demo markdown file for the git workshop.\n## \n##  A new line for testing.\n## \n## -Contains standalone R scripts for staged deliverables to client.\n## +Contains standalone R scripts.\n## +\n## +Test by Sylvie\n\nYou can see the line that I introduced and also the change that Sylvie added and committed to the remote. There are a few options to resolve this. Most people use git pull which runs a two-step process. In my opinion, while this is convenient, it can get you in to trouble. It is generally safer to split the process up into a fetch and then a merge.\n\ngit fetch\ngit merge\n## Auto-merging readme.md\n## Merge made by the 'ort' strategy.\n##  readme.md | 3 +++\n##  1 file changed, 3 insertions(+)\n\nAnd in this case, the merge appears to have worked correctly.\n\n# first-repo\n\nA demo markdown file for the git workshop.\n\nA new line for testing.\n\nContains standalone R scripts for staged deliverables to client.\n\nTest by Sylvie"
  },
  {
    "objectID": "notebooks/git-collab-fileserver.html#remotes-and-branches",
    "href": "notebooks/git-collab-fileserver.html#remotes-and-branches",
    "title": "11¬† Collaboration 1",
    "section": "11.5 Remotes and branches",
    "text": "11.5 Remotes and branches\nOne key aspect that I have not mentioned to date is for the scenario where new branches are created in a local repository.\nTo list all known branches in both your local repository and the remote (or remotes)\n\ngit branch -a\n##   analysis-03\n##   fix-01\n## * main\n##   remotes/origin/analysis-03\n##   remotes/origin/fix-01\n##   remotes/origin/main\n\nLet‚Äôs say that Mark is asked to develop a new analysis. Learning from past mistakes, he creates an analysis-04 branch and adds the following content to run a non-parameteric surivival analysis.\n\ngit branch analysis-04\n\nTo complete the analysis, the following is added to the branching.R script, which is tested, staged and committed.\n\nmessage(\"\\n\\nANALYSIS OF SURVIVAL OUTCOME (UNSTRATIFIED, NON-PARAMETRIC):\\n\")\n\nlm4 &lt;- survdiff(Surv(w, evt) ~ x, data = d)\nprint(lm4)\n\nFollowing the earlier process, Mark then switches back to main and merges in the new analysis.\n\ngit checkout main\ngit merge analysis-04\n\nand then pushes the change up to the remote repository.\n\ngit push\n\nUnfortunately, this does not establish the analysis-04 branch within the remote. This may or may not be a problem (usually not) but it is worth being aware of, because other users will not be able to get access to the evolution of the files that occurred on the development branch. To push the analysis-04 branch we use:\n\ngit push --set-upstream origin analysis-04\n## Total 0 (delta 0), reused 0 (delta 0), pack-reused 0\n## To /Users/mark/Library/CloudStorage/OneDrive-TheUniversityofSydney(Staff)/first-repo.git\n##  * [new branch]      analysis-04 -&gt; analysis-04\n## branch 'analysis-04' set up to track 'origin/analysis-04'.\n\nAnd now uses can fetch and review this branch within the context of their local repositories."
  },
  {
    "objectID": "notebooks/about.html#repository-status",
    "href": "notebooks/about.html#repository-status",
    "title": "About",
    "section": "Repository status",
    "text": "Repository status\nDetails on github repository files, tags, commits follow:\n\nrepo &lt;- git2r::repository(path = \".\")\nsummary(repo)\n\nLocal:    main /Users/mark/Documents/project/misc-stats/get-going-with-git\nRemote:   main @ origin (https://github.com/maj-biostat/get-going-with-git)\nHead:     [a7e516b] 2023-11-08: First pass at collaboration 1\n\nBranches:         2\nTags:             1\nCommits:         35\nContributors:     1\nStashes:          0\nIgnored files:    3\nUntracked files: 25\nUnstaged files:   0\nStaged files:     0\n\nLatest commits:\n[a7e516b] 2023-11-08: First pass at collaboration 1\n[6e58a92] 2023-11-07: First pass at merge\n[1961517] 2023-11-07: Another restruct. Incremental dev\n[e9c18e7] 2023-11-07: minor edit\n[e9f1bd0] 2023-11-07: Forgot to save"
  }
]