[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Get going with git",
    "section": "",
    "text": "Introduction\nWhen you are getting into the nitty gritty, version control is a large topic. The git, github, github cli and github pages ‚Ä¶ technologies can be daunting to set up and use. However, once you are setup properly and understand how things fit together at a high level, users can go a long way with a minimal set of commands.\nI know, it is true that a little knowledge can be a dangerous thing, but it probably isn‚Äôt quite as bad as complete ignorance.\nGet going with git - aims to provide a minimal knowledge base, sufficient to get you started without having to wade through reams of documentation distributed all over the internet. It can be browsed online or downloaded as a word document for your reference.\nWhat is version control? Setting up git Time to commit: working with a local repository Push and pull: working with a remote repository Making your first repository on GitHub Day 2: Collaborating with Others\nDealing with (git) conflicts Branching for sanity Creating pull requests Collaborating with GitHub tools Day 3: Dealing with Complications\nUndoing changes Learning good repository organization principles Ignoring things (in git) Working with large files Using the README Creating GitHub templates Extending git and GitHub with other tools"
  },
  {
    "objectID": "notebooks/preamble.html#background-reading",
    "href": "notebooks/preamble.html#background-reading",
    "title": "Pre-requisites",
    "section": "Background reading",
    "text": "Background reading\nThere is no point reinventing the wheel, Jenny Bryant motivates the use of version control in the following paper: Excuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/preamble.html#command-line-interfaces",
    "href": "notebooks/preamble.html#command-line-interfaces",
    "title": "Pre-requisites",
    "section": "Command line interfaces",
    "text": "Command line interfaces\nA CLI is a software mechanism that you use to interact with your operating system via your keyboard rather than a mouse. You enter in commands as text and the system will do something, e.g.¬†delete a file.\nCLIs are software that are supplied with the operating system. Software that implements such a text interface is often called a command-line interpreter, command processor or a shell.\nNearly universally, if I use the word terminal I am referring to the operating system command line interface.\nWindows refers to its CLI as the command prompt, and in macOS we have the terminal.\nIf you do not know how to operate your operating system CLI then you need to address that.\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nHow to use Windows 10‚Äôs Command Prompt\nLearning Windows Terminal\n\nThe following link needs admin rights (TKI people probably won‚Äôt have nor will be able to obtain these rights) and is not strictly necessary here, but it gives a lot of useful commands and an opportunity to gain a bit more familiarity with the commandline.\n\n40 Windows Commands you NEED to know\n\n\n\nmacOS\n\nHow To Use Terminal On Your Mac\nWhat Is the Mac Terminal?\nAbsolute BEGINNER Guide to the Mac OS Terminal\n\n\n\nExtra credit\n\nLearn the command line"
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management---environment-variables",
    "href": "notebooks/preamble.html#operating-system-management---environment-variables",
    "title": "Pre-requisites",
    "section": "Operating system management - environment variables",
    "text": "Operating system management - environment variables\nYou will need to have some minimal technical competence in driving your computer. At a minimum, you need to know how to set an environment variable under your operating system of choice. If you do not know how to set an environment variable, then you need to address that.\nOther items that are important to be familiar with are file and directory concepts. For example, if you do not know what the command tree does, then it would be useful to find out. Similarly, if you do not know what file permissions are then, again, it would be useful to find out.\n\nWindows\nYou can do these tutorials to familiarise yourselves:\n\nEnvironment Variables : Windows 10\nHow to Set Environment Variables in Windows 11\n\nyou should be able to set a user variable even if you do not have admin priviledges.\n\n\nmacOS\n\nHow to Set Environment Variables in MacOS\nPATH Variable (Mac)\nUse environment variables in Terminal on Mac"
  },
  {
    "objectID": "notebooks/preamble.html#operating-system-management",
    "href": "notebooks/preamble.html#operating-system-management",
    "title": "Pre-requisites",
    "section": "Operating system management",
    "text": "Operating system management\nCreate a directory on your machine where we will store all the files for this workshop.\nSimply go to the your Documents directory and create a sub-dir called get-going-with-git.\nThroughout this text, if I say go to your local workshop directory, this is the location I want you to go to."
  },
  {
    "objectID": "notebooks/preamble.html#github",
    "href": "notebooks/preamble.html#github",
    "title": "Pre-requisites",
    "section": "GitHub",
    "text": "GitHub\nFollow part 1 of the instructions provided by Getting started with your GitHub account to create and configure your account.\n\n\n\n\n\n\nWarning\n\n\n\nThe part on configuring 2-factor authentication is absolutely mandatory, the rest of the 2-factor content can be skimmed. See Configuring two-factor authentication.\n\n\nTo use the USyd GitHub Enterprise Server, you will need a unikey. If you have a unikey, you should have access. Go here and confirm that you can login."
  },
  {
    "objectID": "notebooks/part-01.html",
    "href": "notebooks/part-01.html",
    "title": "Part 1 - Logistical elements",
    "section": "",
    "text": "In this part we will get everything set up. This may well be the hardest part."
  },
  {
    "objectID": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "href": "notebooks/what-is-revision-control.html#sec-what-is-big-pic",
    "title": "1¬† What is (this thing) called revision control",
    "section": "1.1 The big picture",
    "text": "1.1 The big picture\nFirst, let‚Äôs briefly introduce some minimal terminology and context.\n\n\n\n\n\n\nNote\n\n\n\nTODO - Timelines\n\n\nA repository is the mechanism that is used to implement version control by git.\n\n\n\n\n\n\nNote\n\n\n\nThe repository is implemented by a hidden directory called .git that exists within the project directory and contains all the data on the changes that have been made to the files in the project. You should never touch this directory nor its contents.\n\n\nThere are two types of repositories, local and remote.  The local repositories reside on your machine. Remote repositories are hosted by service providers, the most common being GitHub, GitLab and Bitbucket. We only deal with GitHub here. GitHub comes in a few varieties:\n\nGitHub Enterprise is hosted by the company called GitHub, see github.com. It is a commercial platform, but parts of it are made freely available.\nGitHub Enterprise Server is self-hosted; this is what USyd provides via https://github.sydney.edu.au/\n\nIn a nutshell, git provides a set of commands that allow you to manage the files that are retained in these local and remote repositories.\nAgain, I cannot sum it up better than Jenny, so please take the time to read it.\nExcuse Me, Do You Have a Moment to Talk About Version Control?"
  },
  {
    "objectID": "notebooks/what-is-revision-control.html#why-commandline",
    "href": "notebooks/what-is-revision-control.html#why-commandline",
    "title": "1¬† What is (this thing) called revision control",
    "section": "1.2 Why commandline",
    "text": "1.2 Why commandline\nBecause it is the best way."
  },
  {
    "objectID": "notebooks/git-install.html#rstudio",
    "href": "notebooks/git-install.html#rstudio",
    "title": "2¬† Git install",
    "section": "2.1 RStudio",
    "text": "2.1 RStudio\nDevelopers - is your instance of RStudio up to date? If not, update it. Ditto for R. Keep them both updated."
  },
  {
    "objectID": "notebooks/git-install.html#install-git",
    "href": "notebooks/git-install.html#install-git",
    "title": "2¬† Git install",
    "section": "2.2 Install git",
    "text": "2.2 Install git\nI am going to break this down into Mac and Windows because they are the two systems that most of AHI seem to use and the installation is somewhat different for each. If you are using Linux, you probably have no need to be reading this.\n\n2.2.1 Mac OSX\nFirst, do you have git installed already? Launch the terminal app (see the pre-requisites on the landing page if you do not know how to do this). In the terminal, type:\nwhich git\nwhich should show the location of the version of git in use:\n## /opt/homebrew/bin/git\nIf you have homebrew (see below) installed, you can just type:\nbrew install git\nand git will be installed, otherwise, follow the instructions below and then come back here.\nOnce git is installed run the which git command again and then run git --version which is shown (along with the output) below:\ngit --version\n## git version 2.42.0\nIf you got here, then you have git installed. You can close down terminal, open it up again and then run the git --version command again to make certain that everything is ok.\n\n\n2.2.2 Homebrew\nIn the previous section, you can see that the path output from the which git command includes homebrew. For macOS, homebrew is a package manager. This basically just lets you install and manage packages (applications) on your mac.\nTo use homebrew, you need to install it first. To do that, go here, then follow the instructions, which amount to going to the terminal and running the commands listed below.\nPlease go and read the landing page for homebrew before you proceed any further.\nThe first command ensures that pre-requisites are met, see here:\n xcode-select --install\nif this has already been doing you will get an error, or be asked to run Software Update. Generally, you can just move on to the next command:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\ncurl is a tool for transferring data from a url. It is usually stored under /usr/bin but if you are having issues then exporting the following might assist:\nexport HOMEBREW_FORCE_BREWED_CURL=1\nwhich basically tells homebrew to use its own version of curl. After the above is complete, homebrew should be installed. Now you can run\nbrew install git\nto install git for you.\nFor reference, here are a minimal set of commands for using homebrew (additional information can be found in the homebrew man pages).\nBasic information on homebrew:\n# Display the version of Homebrew.\n$ brew --version\n# Print Help Information\n$ brew help\n# Print Help Info for a brew command\n$ brew help &lt;sub-command&gt;\n# Check system for potential problems.\n$ brew doctor\nKeep your homebrew applications up to date:\n# Fetch latest version of homebrew and formula\n$ brew update\n# Show formulae with an updated version available\n$ brew outdated\n# Upgrade all outdated and unpinned brews\n$ brew upgrade\n# Upgrade only the specified brew\n$ brew upgrade &lt;formula&gt;\n# Prevent the specified formulae from being upgraded\n$ brew pin &lt;formula&gt;\n# Allow the specified formulae to be upgraded.\n$ brew unpin &lt;formula&gt;\nThe core commands for managing commandline applications are:\n# List all the installed formulae.\n$ brew list\n# Display all locally available formulae for brewing.\n$ brew search\n# Perform a substring search of formulae names for brewing.\n$ brew search &lt;text&gt;\n# Display information about the formula.\n$ brew info &lt;formula&gt;\n# Install the formula.\n$ brew install &lt;formula&gt;\n# Uninstall the formula.\n$ brew uninstall &lt;formula&gt;\n# Remove older versions of installed formulae.\n$ brew cleanup\nHomebrew casks allow you to install GUI applications. Unless you are an advanced user, you will rarely need to use these, but for completeness:\n# Tap the Cask repository from Github.\n$ brew tap homebrew/cask\n# List all the installed casks .\n$ brew cask list\n# Search all known casks based on the substring text.\n$ brew search &lt;text&gt;\n# Install the given cask.\n$ brew cask install &lt;cask&gt;\n# Reinstalls the given Cask\n$ brew cask reinstall &lt;cask&gt;\n# Uninstall the given cask.\n$ brew cask uninstall &lt;cask&gt;\n\n\n2.2.3 Windows\nThe official site for the git windows binary download is https://git-scm.com/download/win.\nDownload the 64-bit standalone installer, run it, agree to the conditions and license, choose the default location.\nEnsure that the following install components are chosen:\n\nwindows explorer integration\nlarge file support\n\nand accept any other defaults.\nWith the exception of the following, for any of the other prompts, just accept the defaults.\n\nYou will need to nominate a text file editor for editing commit messages and so on. Unless, you know what you are doing, I would advise just select the Windows Notepad application, you can reconfigure this later if you want to.\nYou should select to override the default branch name as main. The reason to do this is so that git aligns with github (which uses main as its default branch).\nFor adjusting the PATH environment variable, ensure that you select Git from the command line and also from 3rd-party software which is the default.\nEnsure that line ending conversion is set to Checkout as-is, commit as-is.\nFor the terminal emulator, select Use Windows default console window. This has some limitations but it is ok for an introduction.\nEnsure that Git Credential Manager Core is selected when prompted.\n\nWe will run through this install for someone in the group.\nTo keep git up to date, you will need to go to the above site and download and reinstall git.\nOpen the command prompt and type:\ngit --version\n## git version 2.42.0"
  },
  {
    "objectID": "notebooks/git-setup.html#configuration-for-git",
    "href": "notebooks/git-setup.html#configuration-for-git",
    "title": "3¬† Git setup",
    "section": "3.1 Configuration for git",
    "text": "3.1 Configuration for git\nPer the sentiment of Fred Basset, you are now up but not quite running.\n\n\n\nFred Basset\n\n\nOne of the first things we need to do is to set a username and email address:\ngit config --global user.name \"Fred\"\ngit config --global user.email \"fred.basset@comic-land.com\"\nYou can list your configuration with\ngit config --global --list\nWe will get into the why later, but basically any interaction you have with git will be tied to your username and email address. This has obvious benefits if we want to be able to figure out who has done what, when and why.\ngit config --global init.defaultBranch \"main\""
  },
  {
    "objectID": "notebooks/github-setup.html#sec-github-setup",
    "href": "notebooks/github-setup.html#sec-github-setup",
    "title": "4¬† Github setup",
    "section": "4.1 GitHub account",
    "text": "4.1 GitHub account\nAs noted in the pre-requisites for using this knowledge base, you have to have GitHub account.\nWhile there are multiple ways to interact with GitHub from your local machine, here we will use the commandline. There are two protocols that can be used, HTTPS and SSH. We will use HTTPS.\nFirst we need to set up a Personal access token.\n\n4.1.1 Personal access token\nGitHub introduced personal access tokens a short while ago. Personal access tokens are basically a password with some bells and whistles.\n\nLogin to your GitHub account.\nOpen Creating a personal access token (classic) in a new tab in your browser and follow the instructions.\nSet the expiry to at least several months into the future."
  },
  {
    "objectID": "notebooks/github-setup.html#git-credential-manager",
    "href": "notebooks/github-setup.html#git-credential-manager",
    "title": "4¬† Github setup",
    "section": "4.2 Git Credential manager",
    "text": "4.2 Git Credential manager\nThe GCM is a platform agnostic credential manager (in English, that translates loosely to a password manager). Once it‚Äôs installed and configured, Git Credential Manager is called by git and you shouldn‚Äôt need to do anything special.\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you‚Äôll also need to complete the 2FA challenge.\nOnce you‚Äôve authenticated successfully, your credentials are stored in the macOS keychain and will be used every time you clone an HTTPS URL. Git will not require you to type your credentials in the command line again unless you change your credentials.\n\n4.2.1 GCM install\nFor Windows users it can be installed by selecting this option during the installation wizard, see Section¬†2.2.3, step 6.\nFor macOS, use homebrew again, specifically:\nbrew install --cask git-credential-manager\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## ############################################################################################################################################## 100.0%\n## ==&gt; Downloading https://github.com/git-ecosystem/git-credential-manager/releases/download/v2.3.2/gcm-osx-arm64-2.3.2.pkg\n## ==&gt; Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/158405551/3b89ee5f-5275-4316-a794-6f39e38849c4?X-Am\n## ############################################################################################################################################## 100.0%\n## ==&gt; Installing Cask git-credential-manager\n## ==&gt; Running installer for git-credential-manager with sudo; the password may be necessary.\n## Password:\n## installer: Package name is Git Credential Manager\n## installer: Installing at base path /\n## installer: The install was successful.\n## üç∫  git-credential-manager was successfully installed!\n\n\n4.2.2 GCM demo\nBelow I demo the process by cloning a private repository from my GitHub account.\n192-168-1-100:tmp mark$ git clone https://github.com/maj-biostat/wisca_2.git\nCloning into 'wisca_2'...\ninfo: please complete authentication in your browser...\nat this point the following window is launch by GCM:\n\n\n\nGCM\n\n\nselecting Sign in with your browser the following will launch in your default browser (Chrome, Safari, etc)\n\n\n\nSign in with browser\n\n\nselecting Authorize git-ecosystem will result in\n\n\n\nSign in with browser\n\n\nat which point you use the 2-factor authenticator tool (I use google authenticator) to respond with an authentication code.\n\n\n\nAuth success\n\n\nLooking back at the terminal, the following output can be observed, which details the repository being cloned.\nremote: Enumerating objects: 297, done.\nremote: Counting objects: 100% (297/297), done.\nremote: Compressing objects: 100% (156/156), done.\nremote: Total 297 (delta 148), reused 284 (delta 137), pack-reused 0\nReceiving objects: 100% (297/297), 7.85 MiB | 2.13 MiB/s, done.\nResolving deltas: 100% (148/148), done.\nFinally, you will receive an email of this sort:\nHey maj-biostat!\n\nA first-party GitHub OAuth application (Git Credential Manager) with gist, repo, and workflow scopes was recently authorized to access your account.\nVisit https://github.com/settings/connections/applications/0120e057bd645470c1ed for more information.\n\nTo see this and other security events for your account, visit https://github.com/settings/security-log\n\nIf you run into problems, please contact support by visiting https://github.com/contact\n\nThanks,\nThe GitHub Team\nOn repeating this process a second time, all the authentication works in the background and there will be no need to go through various authentication handshakes again.\nThe same process applies irrespective of whether you are using GitHub.com or the USyd GitHub Enterprise Server. However, it is adviseable to get this working in GitHub first and then work on getting it to work in the USyd GitHub Enterprise Server.\nThe transition from the old authentication approach has (so far) proved completely seemless for macOS. It will be interesting to see what happens for the Windows platform.\n\n\n4.2.3 GCM configuration (advanced only)\nYou can view the current credential manager by running the following commands:\ngit config --local credential.helper\ngit config --global credential.helper\n# /usr/local/share/gcm-core/git-credential-manager\ngit config --system credential.helper\nOf the local, global and system, the first one checks the local repository config, the second is your ~/.gitconfig, and the third is based on where git is installed. Note that only one credential help is configured in the above example.\nIn some circumstances you may need to reconfigure things. If you have to start from scratch, the following may be useful:\ngit config --local --unset credential.helper\ngit config --global --unset credential.helper\ngit config --system --unset credential.helper\nFor windows uses check the contents of the credential manager. This can be accessed via Control Panel &gt;&gt; All Control Panel Items &gt;&gt; Credential Manager or by simply typing Credential Manager in the Windows task bar. Under generic credentials you should see the git entries."
  },
  {
    "objectID": "notebooks/github-setup.html#github-cli",
    "href": "notebooks/github-setup.html#github-cli",
    "title": "4¬† Github setup",
    "section": "4.3 GitHub CLI",
    "text": "4.3 GitHub CLI\nIn the day to day grind, having to deal with GitHub through its Web interface can be a little cumbersome. You can obviate having to interact with GitHub through the browser by using the GitHub CLI. This tooling allows you to review, create and manage your repositories from the comfort of your commandline. You can think of it as an extension of git that allows you to invoke the GitHub specific functionality.\nThe extremely term gh CLI manual can be found here.\nFor Windows users, you can pick up the latest Signed MSI executables from the release page.\nFor macOS, use homebrew:\nbrew install gh\n## ==&gt; Downloading https://formulae.brew.sh/api/formula.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json\n## #################################################################################################################################### 100.0%\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/manifests/2.37.0\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/331c0b76fd34aa97342efa0e4e41373dbac71c28aeb49346b1284b3450f4105b--gh-2.37.0.bottle_manifest.json\n## ==&gt; Fetching gh\n## ==&gt; Downloading https://ghcr.io/v2/homebrew/core/gh/blobs/sha256:a8c21e08d77963c2d12102aefe38f8c010c573b771ccf729ea438c40dddb7f3a\n## Already downloaded: /Users/mark/Library/Caches/Homebrew/downloads/d0e6a3f8f7a4b138b36484ec9ec8aff26b499381a0b4459f53efc0aefe001ee2--gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Pouring gh--2.37.0.arm64_ventura.bottle.tar.gz\n## ==&gt; Caveats\n## Bash completion has been installed to:\n##   /opt/homebrew/etc/bash_completion.d\n## ==&gt; Summary\n## üç∫  /opt/homebrew/Cellar/gh/2.37.0: 191 files, 44.2MB\n## ==&gt; Running `brew cleanup gh`...\n## Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.\n## Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).\n\n4.3.1 GitHub CLI authentication\nIn order to make use of gh we need to go through another round of authentication setup. To do this, go to the terminal and run:\ngh auth login\n## ? What account do you want to log into? GitHub Enterprise Server\n## ? GHE hostname: github.sydney.edu.au\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\nFor additional information, see gh auth ‚Äìhelp.\nIn order to use gh with github.com directly you need to authenticate for that platform too. Repeat the above, but now the responses look like this:\ngh auth login\n## ? What account do you want to log into? GitHub.com\n## ? What is your preferred protocol for Git operations? HTTPS\n## ? Authenticate Git with your GitHub credentials? Yes\n## ? How would you like to authenticate GitHub CLI? Login with a web browser\nYou are nearly set. You can verify that what you have configured worked via:\ngh auth status\n## github.sydney.edu.au\n##   ‚úì Logged in to github.sydney.edu.au as mjon7053 (keyring)\n##   ‚úì Git operations for github.sydney.edu.au configured to use https protocol.\n##   ‚úì Token: gho_************************************\n##   ‚úì Token scopes: gist, read:org, repo, workflow\n## \n## github.com\n##   ‚úì Logged in to github.com as maj-biostat (keyring)\n##   ‚úì Git operations for github.com configured to use https protocol.\n##   ‚úì Token: gho_************************************\n##   ‚úì Token scopes: gist, read:org, repo, workflow\nHowever, for gh to work with the desired host you need to set an environment variable to tell gh which platform to use. On macOS, you can set this up easily with the following entries in the .profile shell initialisation script (or .bash_profile for those inclined).\ngh-ent() {\n  export GH_HOST=github.sydney.edu.au\n}\n\ngh-std() {\n  export GH_HOST=github.com\n}\nOn Windows, I have no idea how you are supposed to do the above in an easy manner. You may just have to resort to running\nset GH_HOST=github.sydney.edu.au\nor\nset GH_HOST=github.com\neach time you want to switch.\nNow (on macOS) when you want to interrogate github.com repositories we can use the following commands.\n\n\n\n\n\n\nNote\n\n\n\nDo not worry about the meaning of the commands, this is just to establish that we have configured things correctly.\n\n\ngh-std\ngh repo list\n\n## Showing 30 of 185 repositories in @maj-biostat\n## \n## maj-biostat/misc-notes                         info for manjaro/arch linux setup                                public         1d\n## maj-biostat/wisca_2                            Revised approach to antibiogram                                  private        25d\n## maj-biostat/motc.run                                                                                            private        Sep 11, 2023\n## maj-biostat/motc.sim                           Simulation for motivate c trial                                  private        Sep 11, 2023\n## maj-biostat/motc.stan                          Stan models for motc                                             private        Sep  7, 2023\n## maj-biostat/quarto_demos_basic                 Demo using Quarto to render to word documents with custom te...  private        Aug 23, 2023\n## maj-biostat/BayesDRM                           Dose response models in stan                                     public         May 21, 2023\n## maj-biostat/motc.modproto                                                                                       public         May  1, 2023\nand for the USyd Enterprise GitHub Server, use:\ngh-ent\ngh repo list\n\nShowing 12 of 12 repositories in @mjon7053\n\nmjon7053/motc-mgt            Monitoring statistics for Motivate-C study                       private  1d\nmjon7053/fluvid.analyses     Analyses for fluvid coadministration study (COVID19 + FLU) vacc  private  17d\nmjon7053/motc.sap                                                                             public   Sep 14, 2023\nmjon7053/motc-sim-report     Motivate-C simulation report                                     private  Sep 12, 2023\nmjon7053/roadmap-notes       Notes relating to the ROADMAP project.                           private  Sep  2, 2023\nmjon7053/mjon7053.github.io                                                                   private  Aug 27, 2023"
  },
  {
    "objectID": "notebooks/part-02.html",
    "href": "notebooks/part-02.html",
    "title": "Part 2 - Fundamentals",
    "section": "",
    "text": "Now we will make a start with git. Initially we will focus on using git within the confines of your local machine. Yes, that‚Äôs right, for the moment, we won‚Äôt be using github at all. The point of this is to give you a chance to get to grips with the basic ideas. After the main concepts are bedded in, we will move to thinking about github, which is a whole new beast.\n\nAside.\ngit remote add origin https://github.com/career-karma-tutorials/ck-git gh repo create my-newrepo ‚Äìpublic ‚Äìsource=. ‚Äìremote=upstream ‚Äìpush\nThe first part of the one liner: gh repo create my-newrepo creates and names a repo in your account (note: ‚Äòmy-newrepo‚Äô should be replaced by the repo name of your choice) The -public flag makes sure the repo is public (swap this for -private if necessary) The -source=. flag specifies the source directory to be pushed Finally, the -remote=upstream flag specifies the remote repository to which the local repository is going to be compared with when pushing i.e the ‚Äòupstream‚Äô default."
  },
  {
    "objectID": "notebooks/git-repository.html#git-repositories",
    "href": "notebooks/git-repository.html#git-repositories",
    "title": "5¬† Repositories",
    "section": "5.1 Git repositories",
    "text": "5.1 Git repositories\nA repository is the most basic component of git. It is where you store your files and each files history. Repositories can be public or private, can have multiple collaborators and can be stored locally (on your personal computer) or remotely (in the cloud hosted by a service provider like github).\nUsing git, you can create and configure repositories, add or remove files and review history of the files in the repository.\n\n5.1.1 Initialisation\nThere are two basic ways of creating a repository on your local machine\n\nInitialise a new repository\nClone an existing repository\n\nWe will look at initialising a new repository, cloning will come later. Run the following on your machine\n# Change dir to the local workshop directory\nmkdir my-first-repo\ncd my-first-repo\ngit init\n## Initialized empty Git repository in /Users/mark/Documents/project/misc-stats/my-first-repo/.git/\ngit status\n## On branch main\n## \n## No commits yet\n## \n## nothing to commit (create/copy files and use \"git add\" to track)\nIf you received the output detailed above then congratulations, you initialised a git repository.\nIf you have configured your file explorer to show hidden files, you will notice that the my-first-repo directory now contains a .git sub-directory. This directory is the repository. It will contain all the version history and allow you to access a file at any stage in its development. Generally, you will not touch this sub-directory directly.\n\n\n\n\n\n\nNote\n\n\n\nYou can also create a repository from a pre-existing directory that has already got an established file structure and files. The process is exactly the same, just change to the directory that you want to add to version control, and run git init.\nAdditionally, when you create a new project in Rstudio, you can select to initialise a new git repository. Underneath the covers, RStudio is simply invoking git init.\n\n\n\n\n5.1.2 Repository structures\nBefore we start adding files to the new repository, you need to be aware of a few concepts.\nThere are three main structures within the repository:\n\nWorking directory\nStaging area\nCommit history\n\n\n\n\nRepository structures\n\n\nThe working directory is the usual files and sub-directories within your project directory. You add, update, rename, delete files and direcotries in this area. When you first create a file or directory within the working directory, it is not yet under version control. Such files are referred to as untracked files.\nThe staging area is a special space to which files are added when we want to put them under version control.\nAfter staging files, they are committed to the repository. Once committed, files (and directories) are under version control and are referred to as tracked files. A commit is simply a version, but you could also think of it as a transaction with the repository. Changes to committed files are monitored and new updates to files can be committed to the repository as work on the project progresses. Every time you commit files, the commit history is saved."
  },
  {
    "objectID": "notebooks/git-commit.html#adding-files-to-projects",
    "href": "notebooks/git-commit.html#adding-files-to-projects",
    "title": "6¬† Commit",
    "section": "6.1 Adding files to projects",
    "text": "6.1 Adding files to projects\nLet‚Äôs start to introduce files for the project. Open a text editor, enter the following contents:\n\n# my-first-repo\n\nThis is a readme.md file that captures important information about the project.\n\nThe project is only a demo.\n\nsave the file as readme.md in the my-first-repo directory.\nCreate a new file as follows:\n\ncat(\"Enter a string please: \");\na &lt;- readLines(\"stdin\",n=1);\ncat(\"You entered\")\n\nstr(a);\ncat( \"\\n\" )\ncat(a, file = \"log.txt\")\n\nsave the file as hello.R in the my-first-repo directory.\nOr, download these files - hello.R readme.md.\nNow run the R script from the terminal by entering this text:\n\nRscript hello.R\n\nNow from the terminal in the my-first-repo director, type:\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  hello.R\n##  readme.md\n##  log.txt\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)\n\nWe see that there are three untracked files, two of which we will ultimately want to store in the git repository. In contrast to the newly initialised repository as shown in Section¬†5.1.2 we now have the following:\n\n\n\nAdd file to working directory\n\n\nThe above is idealised. You may encounter the situation where you have many files, a number of which you have no intention of tracking under version control. You can ignore these files by creating a .gitignore file, which tells git which files it should ignore.\nCreate a new text file with the following content:\n\nlog.txt\n\nsave the file as .gitignore. Now run git status again:\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Untracked files:\n##   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n##  .gitignore\n##  hello.R\n##  readme.md\n## \n## nothing added to commit but untracked files present (use \"git add\" to track)\n\nand note that the log.txt file no longer registers with git."
  },
  {
    "objectID": "notebooks/git-commit.html#commit-process",
    "href": "notebooks/git-commit.html#commit-process",
    "title": "6¬† Commit",
    "section": "6.2 Commit process",
    "text": "6.2 Commit process\nNext, we want to add the new file to the repository. The steps are\n\nAdd the file (or files) that we want to include in the repository to the staging area\nCommit the staged files\n\n\n6.2.1 Staging\nTo add the files into the staging area run the commands:\n\ngit add hello.R readme.md .gitignore\n\nNote that the .gitignore file was added as well as the hello.R and readme.md files. Now run\n\ngit status\n## On branch main\n## \n## No commits yet\n## \n## Changes to be committed:\n##   (use \"git rm --cached &lt;file&gt;...\" to unstage)\n##  new file:   .gitignore\n##  new file:   hello.R\n##  new file:   readme.md\n\nWe can see that no commits have occurred but that we have staged the files that we want to add to the repository. What happens if we added a file that we did not want to add (the -f says we want to add a file that is included in the .gitignore list).\n\ngit add -f log.txt\n\nif you run git status you will see that log.txt is also staged. To remove log.txt from the staged area:\n\ngit reset log.txt\n\nNow the picture looks like this.\n\n\n\nAdd file to staging area\n\n\n\n\n6.2.2 Commit\nTo commit the files that have been staged:\n\ngit commit -m \"First commit\" \n## [main (root-commit) 728d107] First commit\n##  3 files changed, 15 insertions(+)\n##  create mode 100644 .gitignore\n##  create mode 100644 hello.R\n##  create mode 100644 readme.md\n\nthe -m flag provides a message that is associated with the commit. Now when we run git status we see that the repository is up to date with the working area files. We also see that the files have been removed from the staging area.\n\ngit status\n## On branch main\n## nothing to commit, working tree clean\n\n\n\n\nCommit files to history\n\n\nBut what is the weird number in the commit history? It is basically a unique hash code that identifies this specific version of the project. Note, you will have a different hash code (and that is fine)."
  },
  {
    "objectID": "notebooks/git-commit.html#exercises",
    "href": "notebooks/git-commit.html#exercises",
    "title": "6¬† Commit",
    "section": "6.3 Exercises",
    "text": "6.3 Exercises\n\nExercise 6.1 Create a new R script in the working directory, it can contain anything you like. If you are lost, just use:\n\nlibrary(survival)\nprint(\"My script\")\n\nand save it as myscript.R.\n\n\nExercise 6.2 Add the new script to the staging area by following Section¬†6.2.1 ensuring that you review the status.\n\n\nExercise 6.3 Commit the staged files to the repository by following Section¬†6.2.2 making sure that you record a message for your commit.\n\n\nExercise 6.4 Edit the readme.md file adding a new line with some arbitrary text. Stage the file and commit."
  },
  {
    "objectID": "notebooks/git-commit.html#tracking-commit-history",
    "href": "notebooks/git-commit.html#tracking-commit-history",
    "title": "6¬† Commit",
    "section": "6.4 Tracking commit history",
    "text": "6.4 Tracking commit history\nOne of the primary features of revision control is that you can review your project file history. The simplest way to do this is with git log which will report all of the commits in reverse chronological order. You can see\n\nthat three commits have been made, all by myself with my email address listed\nthe time the commits were made and the message associated with each\nthe hash code associated with project version at each commit\n\nnote that the full hash is reported whereas previous a truncated version is shown\n\n\nThe commit followed by (HEAD -&gt; main) shows what part of the history our working directory currently reflects.\n\ngit log\n## commit 050a9d4e989313900010d19554d450e9efc9621c (HEAD -&gt; main)\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Thu Nov 2 14:19:16 2023 +0800\n## \n##     Updated readme.md with installation instructions.\n## \n## commit 37e05b5985e455fdeb30a8c9883914750e3f9897\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Thu Nov 2 14:18:53 2023 +0800\n## \n##     First commit of myscript.R, testing purposes only\n## \n## commit 728d107a238c12e665dd559c3db7fa9d5beeb2eb\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Thu Nov 2 13:55:09 2023 +0800\n## \n##     First commit\n\nYou can format the logs in a variety of ways. For a more condensed view you can use the --oneline flag:\n\ngit log --oneline\n## 050a9d4 (HEAD -&gt; main) Testing still\n## 37e05b5 Test\n## 728d107 First commit\n\nIf you want the commit history for the last n commits, or between specific dates, or by author or even via searching for a specific string in the message you can run the following\n\ngit log -n 2\ngit log --after=\"2013-11-01\" --before=\"2023-10-15\"\ngit log --author=\"Mark\\|Fred\"\ngit log --grep=\"first\" -i\n\nThe first restricts to the last two commits, the second returns commits between mid Oct and the start of Nov, the second returns commits made by Mark or Fred and the third returns any commits where the word first was included in the message text (ignoring case).\nThe log command is powerful and it lets you see who updated the files, when they made the update and why they did it. Obviously, this has less utility when you are working on a repository in isolation but it still does have value (especially to your future self). For example, you might simply want to review when specific changes were made to the files or you might want to pick up some update that has been removed from the code and reintroduce it.\nWhen you are working on a repository in collaboration (see later) the value of the logs increases many fold as a way to be able to understand the evolution of the project and to work out who you need to contact if you think a problem has been introduced.\nTo establish what files were included in any given commit, you can use git show:\n\ngit show --name-only 728d107\n## commit 728d107a238c12e665dd559c3db7fa9d5beeb2eb\n## Author: Mark &lt;mark.jones1@sydney.edu.au&gt;\n## Date:   Thu Nov 2 13:55:09 2023 +0800\n## \n##     First commit\n## \n## .gitignore\n## hello.R\n## readme.md"
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "href": "notebooks/git-diffs.html#comparisons-with-the-working-directory",
    "title": "7¬† Reviewing differences",
    "section": "7.1 Comparisons with the working directory",
    "text": "7.1 Comparisons with the working directory\nGit allows you to compare different versions of files that exist in the repository. In its vanilla form, the difference functionality compares the differences in a file (or files) in the working directory to the repository version.\nUpdate the contents of the hello.R script to match what follows.\n\ncounter &lt;- 1\nwhile(counter &lt;= 3)\n{\n  cat(paste0(\"Enter string number \", counter, \" \"))\n  a &lt;- readLines(\"stdin\",n=1);\n  cat(\"You entered\")\n  str(a);\n  cat( \"\\n\" )\n  counter &lt;- counter + 1\n}\n\nSimilarly, edit the readme.md file as below.\n\n# my-first-repo\n\nThis is a readme.md file that captures important information about the project.\n\nThe project is only a demo.\n\nThe main script implements a loop to capture input from a user.\n\nRunning git status you will see that the working directory uncommitted changes\n\ngit status\n## On branch main\n## Changes not staged for commit:\n##   (use \"git add &lt;file&gt;...\" to update what will be committed)\n##   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n##  modified:   hello.R\n##  modified:   readme.md\n## \n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf we want to know what changes were made, we can run git diff but let‚Äôs looks at the differences on a file by file basis, comparing the old with the new.\n\ngit diff readme.md\n## diff --git a/readme.md b/readme.md\n## index 4826780..6c84404 100644\n## --- a/readme.md\n## +++ b/readme.md\n## @@ -4,6 +4,5 @@ This is a readme.md file that captures important information about the project.\n## \n##  The project is only a demo.\n## \n## -A minor revision.\n## -\n## +The main script implements a loop to capture input from a user.\n\nYou interpret the above as follows.\n\nAnything prefixed with - belongs to the old file and anything prefixed with + belongs to the new.\nThe section labelled with @@ gives you some context as to where the change has happened. In this case we can see that the text A minor revision has been removed and replaced with the text The main script implements a loop to capture input from a user.\n\nNow compare the working version of hello.R with the repository version, but this time look at the word by word differences:\n\ngit diff --word-diff hello.R\n## diff --git a/hello.R b/hello.R\n## index 674a20f..624f356 100644\n## --- a/hello.R\n## +++ b/hello.R\n## @@ -1,9 +1,12 @@\n## [-cat(\"a-]{+counter &lt;- 1+}\n## {+while(counter &lt;= 3)+}\n## {+{+}\n## {+  cat(paste0(\"Enter+} string [-please: \");-]{+number \", counter, \" \"))+}\n##   a &lt;- readLines(\"stdin\",n=1);\n##   cat(\"You [-entered\")-]{+entered \")+}\n##   str(a);\n##   cat( \"\\n\" )\n##   [-cat(a, file = \"log.txt\")-]{+counter &lt;- counter + 1+}\n## {+}+}\n\nThe diffs can take a bit of getting used to and some alternative tools are available that we will put to use in due course. For now, we will just deal with the commandline output.\nOnce satisfied that the changes are benign, stage and commit the edits in the usual way:\n\ngit add hello.R readme.md\ngit commit -m \"Revised approach in capturing user input\""
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "href": "notebooks/git-diffs.html#comparisons-with-staged-files",
    "title": "7¬† Reviewing differences",
    "section": "7.2 Comparisons with staged files",
    "text": "7.2 Comparisons with staged files\nIf you want to restrict your attention to the differences that will be made to a repository due to committing staged files, you can use git diff --cached."
  },
  {
    "objectID": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "href": "notebooks/git-diffs.html#comparisons-across-commit-versions",
    "title": "7¬† Reviewing differences",
    "section": "7.3 Comparisons across commit versions",
    "text": "7.3 Comparisons across commit versions\nOnce working directory changes have been committed to the repository it is still possible to review the differences between commit.\nThe most common difference that is of interest is that between the last two commits. To achieve this run\n\ngit diff HEAD\n\nMore generally, to inspect differences between any commits, you simply supply the commit hashes that you want to compare:\n\ngit log --oneline\n## 050a9d4 (HEAD -&gt; main) Testing still\n## 37e05b5 Test\n## 728d107 First commit\ngit diff 728d107 37e05b5\n## diff --git a/myscript.R b/myscript.R\n## new file mode 100644\n## index 0000000..a12204c\n## --- /dev/null\n## +++ b/myscript.R\n## @@ -0,0 +1,3 @@\n## +library(survival)\n## +print(\"My script\")\n## +\n\nIf you want to restrict attention to a particular file, just add the filename that you want to compare to the end of the command\n\ngit diff 050a9d4 bb1529a hello.R\n## diff --git a/hello.R b/hello.R\n## index 674a20f..624f356 100644\n## --- a/hello.R\n## +++ b/hello.R\n## @@ -1,9 +1,12 @@\n## -cat(\"a string please: \");\n## -a &lt;- readLines(\"stdin\",n=1);\n## -cat(\"You entered\")\n## - str(a);\n## -cat( \"\\n\" )\n## -cat(a, file = \"log.txt\")\n## -\n## +counter &lt;- 1\n## +while(counter &lt;= 3)\n## +{\n## +  cat(paste0(\"Enter string number \", counter, \" \"))\n## +  a &lt;- readLines(\"stdin\",n=1);\n## +  cat(\"You entered \")\n## +  str(a);\n## +  cat( \"\\n\" )\n## +  counter &lt;- counter + 1\n## +}"
  },
  {
    "objectID": "notebooks/git-branch.html#why-branches",
    "href": "notebooks/git-branch.html#why-branches",
    "title": "8¬† Branches",
    "section": "8.1 Why branches?",
    "text": "8.1 Why branches?"
  },
  {
    "objectID": "notebooks/git-branch.html#what-is-a-branch",
    "href": "notebooks/git-branch.html#what-is-a-branch",
    "title": "8¬† Branches",
    "section": "8.2 What is a branch?",
    "text": "8.2 What is a branch?"
  },
  {
    "objectID": "notebooks/git-branch.html#special-branch-concepts",
    "href": "notebooks/git-branch.html#special-branch-concepts",
    "title": "8¬† Branches",
    "section": "8.3 Special branch concepts",
    "text": "8.3 Special branch concepts"
  },
  {
    "objectID": "notebooks/git-branch.html#creating-a-branch",
    "href": "notebooks/git-branch.html#creating-a-branch",
    "title": "8¬† Branches",
    "section": "8.4 Creating a branch",
    "text": "8.4 Creating a branch"
  },
  {
    "objectID": "notebooks/git-branch.html#switching-branches",
    "href": "notebooks/git-branch.html#switching-branches",
    "title": "8¬† Branches",
    "section": "8.5 Switching branches",
    "text": "8.5 Switching branches"
  },
  {
    "objectID": "notebooks/git-branch.html#working-on-branches",
    "href": "notebooks/git-branch.html#working-on-branches",
    "title": "8¬† Branches",
    "section": "8.6 Working on branches",
    "text": "8.6 Working on branches"
  },
  {
    "objectID": "notebooks/git-merge.html#merge-concepts",
    "href": "notebooks/git-merge.html#merge-concepts",
    "title": "9¬† Merge",
    "section": "9.1 Merge concepts",
    "text": "9.1 Merge concepts"
  },
  {
    "objectID": "notebooks/git-merge.html#merge-processes",
    "href": "notebooks/git-merge.html#merge-processes",
    "title": "9¬† Merge",
    "section": "9.2 Merge processes",
    "text": "9.2 Merge processes"
  },
  {
    "objectID": "notebooks/git-tags.html#section",
    "href": "notebooks/git-tags.html#section",
    "title": "10¬† Tags",
    "section": "10.1 ",
    "text": "10.1"
  },
  {
    "objectID": "notebooks/git-history.html#section",
    "href": "notebooks/git-history.html#section",
    "title": "11¬† Reviewing history",
    "section": "11.1 ",
    "text": "11.1"
  },
  {
    "objectID": "notebooks/part-03.html",
    "href": "notebooks/part-03.html",
    "title": "Part 3 - Collaboration",
    "section": "",
    "text": "Remotes\nHosting git"
  },
  {
    "objectID": "notebooks/about.html#repository-status",
    "href": "notebooks/about.html#repository-status",
    "title": "About",
    "section": "Repository status",
    "text": "Repository status\nDetails on github repository files, tags, commits follow:\n\nrepo &lt;- git2r::repository(path = \".\")\nsummary(repo)\n\nLocal:    main /Users/mark/Documents/project/misc-stats/get-going-with-git\nRemote:   main @ origin (https://github.com/maj-biostat/get-going-with-git)\nHead:     [c472861] 2023-11-02: Updated section title\n\nBranches:         2\nTags:             0\nCommits:         29\nContributors:     1\nStashes:          0\nIgnored files:    3\nUntracked files: 20\nUnstaged files:   0\nStaged files:     0\n\nLatest commits:\n[c472861] 2023-11-02: Updated section title\n[389cc3c] 2023-11-02: First pass at diff\n[0d73ab1] 2023-11-02: First draft of commit processes\n[f61768d] 2023-11-02: Minor edit\n[72867f5] 2023-11-02: Introducing commit instructs"
  }
]